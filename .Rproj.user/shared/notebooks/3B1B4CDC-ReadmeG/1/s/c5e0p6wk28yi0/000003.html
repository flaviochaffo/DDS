<table style="width:100%;">
<caption>Amenazas sobre los activos de Rockwell</caption>
<colgroup>
<col width="0%" />
<col width="0%" />
<col width="0%" />
<col width="0%" />
<col width="9%" />
<col width="83%" />
<col width="0%" />
<col width="0%" />
<col width="0%" />
<col width="0%" />
<col width="0%" />
<col width="0%" />
<col width="2%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">CAPEC</th>
<th align="left">ID</th>
<th align="right">total</th>
<th align="left">pos</th>
<th align="left">Description</th>
<th align="left">Likelihood</th>
<th align="left">Severity</th>
<th align="right">LikelihoodScore</th>
<th align="right">SeverityScore</th>
<th align="right">RiskScore</th>
<th align="left">Risk</th>
<th align="left">Relations</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">21</td>
<td align="left">CAPEC-2</td>
<td align="left">2</td>
<td align="right">51</td>
<td align="left">1, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 16, 17, 18, 20, 22, 23, 24, 25, 27, 30, 31, 32, 33, 34, 36, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 55, 56, 59, 60, 62, 63, 65, 66, 67, 69, 70, 71, 72</td>
<td align="left">An attacker leverages the security functionality of the system aimed at thwarting potential attacks to launch a denial of service attack against a legitimate system user. Many systems, for instance, implement a password throttling mechanism that locks an account after a certain number of incorrect log in attempts. An attacker can leverage this throttling mechanism to lock a legitimate user out of their own account. The weakness that is being leveraged by an attacker is the very security feature that has been put in place to counteract attacks.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">CAPEC-212</td>
</tr>
<tr class="even">
<td align="left">524</td>
<td align="left">CAPEC-1</td>
<td align="left">1</td>
<td align="right">51</td>
<td align="left">1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 16, 17, 18, 22, 23, 24, 25, 27, 30, 31, 32, 33, 34, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 50, 54, 55, 56, 57, 59, 60, 62, 63, 65, 66, 67, 69, 70, 71, 72</td>
<td align="left">In applications, particularly web applications, access to functionality is mitigated by an authorization framework. This framework maps Access Control Lists (ACLs) to elements of the application’s functionality; particularly URL’s for web apps. In the case that the administrator failed to specify an ACL for a particular element, an attacker may be able to access it with impunity. An attacker with the ability to access functionality not properly constrained by ACLs can obtain sensitive information and possibly compromise the entire application. Such an attacker can access resources that must be available only to users at a higher privilege level, can access management sections of the application, or can run queries for data that they otherwise not supposed to.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">T1574.010</td>
</tr>
<tr class="odd">
<td align="left">11</td>
<td align="left">CAPEC-9</td>
<td align="left">9</td>
<td align="right">49</td>
<td align="left">1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 16, 17, 18, 20, 22, 23, 24, 25, 27, 30, 31, 32, 34, 36, 37, 41, 42, 43, 45, 46, 47, 48, 49, 50, 51, 54, 56, 57, 59, 60, 62, 63, 66, 67, 70, 71, 72</td>
<td align="left">This attack targets command-line utilities available in a number of shells. An attacker can leverage a vulnerability found in a command-line utility to escalate privilege to root.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="even">
<td align="left">17</td>
<td align="left">CAPEC-7</td>
<td align="left">7</td>
<td align="right">44</td>
<td align="left">1, 2, 4, 5, 6, 7, 8, 11, 12, 17, 18, 22, 23, 24, 25, 27, 30, 31, 32, 34, 35, 36, 37, 41, 42, 43, 45, 46, 47, 48, 50, 54, 56, 57, 59, 60, 62, 63, 66, 67, 69, 70, 71, 72</td>
<td align="left">Blind SQL Injection results from an insufficient mitigation for SQL Injection. Although suppressing database error messages are considered best practice, the suppression alone is not sufficient to prevent SQL Injection. Blind SQL Injection is a form of SQL Injection that overcomes the lack of error messages. Without the error messages that facilitate SQL Injection, the adversary constructs input strings that probe the target through simple Boolean SQL expressions. The adversary can determine if the syntax and structure of the injection was successful based on whether the query was executed or not. Applied iteratively, the adversary determines how and where the target is vulnerable to SQL Injection.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-66</td>
</tr>
<tr class="odd">
<td align="left">10</td>
<td align="left">CAPEC-8</td>
<td align="left">8</td>
<td align="right">42</td>
<td align="left">1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17, 18, 23, 24, 27, 30, 31, 32, 36, 41, 42, 43, 45, 46, 47, 48, 50, 54, 56, 59, 60, 62, 63, 66, 67, 69, 70, 71, 72, 75</td>
<td align="left">This attack targets libraries or shared code modules which are vulnerable to buffer overflow attacks. An attacker who has access to an API may try to embed malicious code in the API function call and exploit a buffer overflow vulnerability in the function’s implementation. All clients that make use of the code library thus become vulnerable by association. This has a very broad effect on security across a system, usually affecting more than one software process.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="left">CAPEC-47</td>
<td align="left">47</td>
<td align="right">37</td>
<td align="left">1, 2, 4, 5, 6, 7, 8, 11, 12, 17, 18, 23, 24, 27, 30, 31, 32, 36, 41, 42, 45, 46, 47, 48, 50, 54, 56, 57, 59, 60, 62, 63, 66, 67, 70, 71, 72</td>
<td align="left">In this attack, the target software is given input that the attacker knows will be modified and expanded in size during processing. This attack relies on the target software failing to anticipate that the expanded data may exceed some internal limit, thereby creating a buffer overflow.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">CAPEC-14</td>
<td align="left">14</td>
<td align="right">34</td>
<td align="left">1, 4, 5, 6, 7, 8, 11, 17, 18, 22, 24, 25, 27, 30, 31, 32, 34, 36, 41, 42, 45, 46, 47, 50, 54, 56, 59, 60, 62, 63, 66, 67, 70, 71</td>
<td align="left">This type of attack exploits a buffer overflow vulnerability in targeted client software through injection of malicious content from a custom-built hostile service.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">CAPEC-10</td>
<td align="left">10</td>
<td align="right">31</td>
<td align="left">1, 2, 5, 6, 7, 8, 11, 12, 17, 18, 23, 24, 27, 30, 31, 33, 41, 42, 46, 48, 50, 56, 59, 60, 62, 63, 66, 67, 70, 71, 72</td>
<td align="left">This attack pattern involves causing a buffer overflow through manipulation of environment variables. Once the attacker finds that they can modify an environment variable, they may try to overflow associated buffers. This attack leverages implicit trust often placed in environment variables.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="odd">
<td align="left">8</td>
<td align="left">CAPEC-46</td>
<td align="left">46</td>
<td align="right">31</td>
<td align="left">1, 5, 6, 7, 8, 11, 12, 17, 18, 23, 24, 27, 30, 31, 41, 42, 46, 48, 50, 54, 56, 57, 59, 60, 62, 63, 66, 67, 70, 71, 72</td>
<td align="left">This type of attack leverages the use of tags or variables from a formatted configuration data to cause buffer overflow. The attacker crafts a malicious HTML page or configuration file that includes oversized strings, thus causing an overflow.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">CAPEC-24</td>
<td align="left">24</td>
<td align="right">29</td>
<td align="left">1, 5, 6, 7, 8, 11, 12, 17, 18, 23, 24, 27, 30, 31, 41, 42, 46, 48, 50, 56, 59, 60, 62, 63, 66, 67, 70, 71, 72</td>
<td align="left">In this attack, the idea is to cause an active filter to fail by causing an oversized transaction. An attacker may try to feed overly long input strings to the program in an attempt to overwhelm the filter (by causing a buffer overflow) and hoping that the filter does not fail securely (i.e. the user input is let into the system unfiltered).</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="odd">
<td align="left">7</td>
<td align="left">CAPEC-45</td>
<td align="left">45</td>
<td align="right">27</td>
<td align="left">1, 5, 6, 7, 8, 11, 17, 18, 24, 27, 30, 31, 33, 36, 41, 42, 46, 50, 56, 59, 60, 62, 63, 66, 67, 70, 71</td>
<td align="left">This type of attack leverages the use of symbolic links to cause buffer overflows. An attacker can try to create or manipulate a symbolic link file such that its contents result in out of bounds data. When the target software processes the symbolic link file, it could potentially overflow internal buffers with insufficient bounds checking.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">CAPEC-42</td>
<td align="left">42</td>
<td align="right">26</td>
<td align="left">1, 5, 6, 7, 8, 11, 17, 18, 24, 27, 30, 31, 41, 42, 46, 50, 56, 59, 60, 62, 63, 66, 67, 69, 70, 71</td>
<td align="left">An attacker exploits a weakness in the MIME conversion routine to cause a buffer overflow and gain control over the mail server machine. The MIME system is designed to allow various different information formats to be interpreted and sent via e-mail. Attack points exist when data are converted to MIME compatible format and back.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="odd">
<td align="left">184</td>
<td align="left">CAPEC-3</td>
<td align="left">3</td>
<td align="right">22</td>
<td align="left">10, 12, 18, 22, 23, 25, 31, 34, 35, 36, 41, 42, 43, 46, 48, 50, 54, 57, 65, 69, 70, 72</td>
<td align="left">Some APIs will strip certain leading characters from a string of parameters. An adversary can intentionally introduce leading “ghost” characters (extra characters that don’t affect the validity of the request at the API layer) that enable the input to pass the filters and therefore process the adversary’s input. This occurs when the targeted API will accept input data in several syntactic forms and interpret it in the equivalent semantic way, while the filter does not take into account the full spectrum of the syntactic forms acceptable to the targeted API.</td>
<td align="left">Medium</td>
<td align="left">Medium</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="even">
<td align="left">217</td>
<td align="left">CAPEC-92</td>
<td align="left">92</td>
<td align="right">21</td>
<td align="left">10, 12, 14, 18, 20, 23, 31, 41, 42, 46, 48, 49, 50, 51, 59, 60, 62, 63, 66, 70, 72</td>
<td align="left">This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-128</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">CAPEC-44</td>
<td align="left">44</td>
<td align="right">20</td>
<td align="left">1, 5, 6, 7, 8, 11, 17, 24, 27, 30, 33, 56, 57, 59, 60, 62, 63, 66, 67, 71</td>
<td align="left">An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the attacker access to the execution stack and execute arbitrary code in the target process. This attack pattern is a variant of standard buffer overflow attacks using an unexpected vector (binary files) to wrap its attack and open up a new attack vector. The attacker is required to either directly serve the binary content to the victim, or place it in a locale like a MP3 sharing application, for the victim to download. The attacker then is notified upon the download or otherwise locates the vulnerability opened up by the buffer overflow.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100, CAPEC-23</td>
</tr>
<tr class="even">
<td align="left">784</td>
<td align="left">CAPEC-12</td>
<td align="left">12</td>
<td align="right">19</td>
<td align="left">12, 13, 14, 16, 18, 23, 31, 41, 42, 43, 44, 46, 48, 50, 54, 65, 69, 70, 72</td>
<td align="left">This pattern of attack is defined by the selection of messages distributed over via multicast or public information channels that are intended for another client by determining the parameter value assigned to that client. This attack allows the adversary to gain access to potentially privileged information, and to possibly perpetrate other attacks through the distribution means by impersonation. If the channel/message being manipulated is an input rather than output mechanism for the system, (such as a command bus), this style of attack could be used to change the adversary’s identifier to more a privileged one.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-216</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">CAPEC-100</td>
<td align="left">100</td>
<td align="right">18</td>
<td align="left">1, 5, 6, 7, 8, 11, 17, 24, 27, 30, 56, 59, 60, 62, 63, 66, 67, 71</td>
<td align="left">Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries’ choice.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-123</td>
</tr>
<tr class="even">
<td align="left">89</td>
<td align="left">CAPEC-22</td>
<td align="left">22</td>
<td align="right">18</td>
<td align="left">12, 18, 22, 23, 25, 31, 34, 41, 42, 44, 46, 48, 50, 54, 55, 69, 70, 72</td>
<td align="left">An attack of this type exploits vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by communicating directly with the server where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CWE-290, CWE-287, CWE-20 , CWE-200, CWE-693</td>
</tr>
<tr class="odd">
<td align="left">136</td>
<td align="left">CAPEC-59</td>
<td align="left">59</td>
<td align="right">18</td>
<td align="left">10, 12, 13, 16, 18, 22, 23, 25, 31, 34, 36, 41, 42, 46, 48, 50, 70, 72</td>
<td align="left">This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-196</td>
</tr>
<tr class="even">
<td align="left">148</td>
<td align="left">CAPEC-20</td>
<td align="left">20</td>
<td align="right">15</td>
<td align="left">10, 12, 14, 18, 23, 31, 36, 41, 42, 46, 48, 50, 69, 70, 72</td>
<td align="left">An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.</td>
<td align="left">Low</td>
<td align="left">Low</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">CAPEC-112</td>
</tr>
<tr class="odd">
<td align="left">723</td>
<td align="left">CAPEC-19</td>
<td align="left">19</td>
<td align="right">15</td>
<td align="left">4, 12, 14, 22, 23, 25, 32, 34, 37, 45, 47, 48, 54, 57, 72</td>
<td align="left">An attack of this type exploits a programs’ vulnerabilities that are brought on by allowing remote hosts to execute scripts. The adversary leverages this capability to execute their own script by embedding it within other scripts that the target software is likely to execute. The adversary must have the ability to inject their script into a script that is likely to be executed. If this is done, then the adversary can potentially launch a variety of probes and attacks against the web server’s local environment, in many cases the so-called DMZ, back end resources the web server can communicate with, and other hosts. With the proliferation of intermediaries, such as Web App Firewalls, network devices, and even printers having JVMs and Web servers, there are many locales where an attacker can inject malicious scripts. Since this attack pattern defines scripts within scripts, there are likely privileges to execute said attack on the host. These attacks are not solely limited to the server side, client side scripts like Ajax and client side JavaScript can contain malicious scripts as well.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">T1546.004</td>
</tr>
<tr class="even">
<td align="left">73</td>
<td align="left">CAPEC-85</td>
<td align="left">85</td>
<td align="right">14</td>
<td align="left">10, 12, 13, 16, 18, 23, 31, 41, 42, 46, 48, 50, 70, 72</td>
<td align="left">This attack utilizes the frequent client-server roundtrips in Ajax conversation to scan a system. While Ajax does not open up new vulnerabilities per se, it does optimize them from an attacker point of view. A common first step for an attacker is to footprint the target environment to understand what attacks will work. Since footprinting relies on enumeration, the conversational pattern of rapid, multiple requests and responses that are typical in Ajax applications enable an attacker to look for many vulnerabilities, well-known ports, network locations and so on. The knowledge gained through Ajax fingerprinting can be used to support other attacks, such as XSS.</td>
<td align="left">High</td>
<td align="left">Low</td>
<td align="right">4</td>
<td align="right">3</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">CAPEC-580</td>
</tr>
<tr class="odd">
<td align="left">199</td>
<td align="left">CAPEC-64</td>
<td align="left">64</td>
<td align="right">14</td>
<td align="left">12, 18, 23, 31, 33, 41, 42, 43, 46, 48, 50, 69, 70, 72</td>
<td align="left">This attack targets the encoding of the URL combined with the encoding of the slash characters. An attacker can take advantage of the multiple ways of encoding a URL and abuse the interpretation of the URL. A URL may contain special character that need special syntax handling in order to be interpreted. Special characters are represented using a percentage character followed by two digits representing the octet code of the original character (%HEX-CODE). For instance US-ASCII space character would be represented with %20. This is often referred as escaped ending or percent-encoding. Since the server decodes the URL from the requests, it may restrict the access to some URL paths by validating and filtering out the URL requests it received. An attacker will try to craft an URL with a sequence of special characters which once interpreted by the server will be equivalent to a forbidden URL. It can be difficult to protect against this attack since the URL can contain other format of encoding such as UTF-8 encoding, Unicode-encoding, etc.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="even">
<td align="left">519</td>
<td align="left">CAPEC-23</td>
<td align="left">23</td>
<td align="right">14</td>
<td align="left">12, 18, 23, 31, 41, 42, 43, 46, 48, 50, 54, 69, 70, 72</td>
<td align="left">An attack of this type exploits the host’s trust in executing remote content, including binary files. The files are poisoned with a malicious payload (targeting the file systems accessible by the target software) by the adversary and may be passed through standard channels such as via email, and standard web content like PDF and multimedia files. The adversary exploits known vulnerabilities or handling routines in the target processes. Vulnerabilities of this type have been found in a wide variety of commercial applications from Microsoft Office to Adobe Acrobat and Apple Safari web browser. When the adversary knows the standard handling routines and can identify vulnerabilities and entry points, they can be exploited by otherwise seemingly normal content. Once the attack is executed, the adversary’s program can access relative directories such as C:Files or other standard system directories to launch further attacks. In a worst case scenario, these programs are combined with other propagation logic and work as a virus.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-242</td>
</tr>
<tr class="odd">
<td align="left">142</td>
<td align="left">CAPEC-79</td>
<td align="left">79</td>
<td align="right">13</td>
<td align="left">12, 18, 23, 31, 41, 42, 43, 46, 48, 50, 57, 70, 72</td>
<td align="left">This attack targets the encoding of the Slash characters. An attacker would try to exploit common filtering problems related to the use of the slashes characters to gain access to resources on the target host. Directory-driven systems, such as file systems and databases, typically use the slash character to indicate traversal between directories or other container components. For murky historical reasons, PCs (and, as a result, Microsoft OSs) choose to use a backslash, whereas the UNIX world typically makes use of the forward slash. The schizophrenic result is that many MS-based systems are required to understand both forms of the slash. This gives the attacker many opportunities to discover and abuse a number of common filtering problems. The goal of this pattern is to discover server software that only applies filters to one version, but not the other.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="even">
<td align="left">22</td>
<td align="left">CAPEC-82</td>
<td align="left">82</td>
<td align="right">12</td>
<td align="left">4, 18, 31, 32, 41, 42, 45, 46, 47, 50, 54, 70</td>
<td align="left">This attack pattern has been deprecated as it a generalization of CAPEC-230: XML Nested Payloads, CAPEC-231: XML Oversized Payloads, and CAPEC-147: XML Ping of Death. Please refer to these CAPECs going forward.</td>
<td align="left">Unknown</td>
<td align="left">Unknown</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">Low</td>
<td align="left">CWE-</td>
</tr>
<tr class="odd">
<td align="left">87</td>
<td align="left">CAPEC-13</td>
<td align="left">13</td>
<td align="right">12</td>
<td align="left">12, 18, 23, 31, 41, 42, 46, 48, 50, 54, 70, 72</td>
<td align="left">The attacker directly or indirectly modifies environment variables used by or controlling the target software. The attacker’s goal is to cause the target software to deviate from its expected operation in a manner that benefits the attacker.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">T1562.003, T1574.006, T1574.007</td>
</tr>
<tr class="even">
<td align="left">185</td>
<td align="left">CAPEC-31</td>
<td align="left">31</td>
<td align="right">12</td>
<td align="left">12, 18, 23, 31, 41, 42, 46, 48, 50, 54, 70, 72</td>
<td align="left">This attack relies on the use of HTTP Cookies to store credentials, state information and other critical data on client systems. There are several different forms of this attack. The first form of this attack involves accessing HTTP Cookies to mine for potentially sensitive data contained therein. The second form involves intercepting this data as it is transmitted from client to server. This intercepted information is then used by the adversary to impersonate the remote user/session. The third form is when the cookie’s content is modified by the adversary before it is sent back to the server. Here the adversary seeks to convince the target server to operate on this falsified information.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-39 , CAPEC-157</td>
</tr>
<tr class="odd">
<td align="left">201</td>
<td align="left">CAPEC-67</td>
<td align="left">67</td>
<td align="right">12</td>
<td align="left">18, 31, 41, 42, 46, 50, 59, 60, 62, 63, 66, 70</td>
<td align="left">This attack targets the format string vulnerabilities in the syslog() function. An attacker would typically inject malicious input in the format string parameter of the syslog function. This is a common problem, and many public vulnerabilities and associated exploits have been posted.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-100</td>
</tr>
<tr class="even">
<td align="left">205</td>
<td align="left">CAPEC-73</td>
<td align="left">73</td>
<td align="right">12</td>
<td align="left">12, 18, 23, 31, 36, 41, 42, 46, 48, 50, 70, 72</td>
<td align="left">An attack of this type involves an adversary inserting malicious characters (such as a XSS redirection) into a filename, directly or indirectly that is then used by the target software to generate HTML text or other potentially executable content. Many websites rely on user-generated content and dynamically build resources like files, filenames, and URL links directly from user supplied data. In this attack pattern, the attacker uploads code that can execute in the client browser and/or redirect the client browser to a site that the attacker owns. All XSS attack payload variants can be used to pass and exploit these vulnerabilities.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-165</td>
</tr>
<tr class="odd">
<td align="left">215</td>
<td align="left">CAPEC-99</td>
<td align="left">99</td>
<td align="right">12</td>
<td align="left">12, 18, 23, 31, 41, 42, 46, 48, 50, 54, 70, 72</td>
<td align="left">This attack pattern has been deprecated as it a generalization of CAPEC-230: XML Nested Payloads and CAPEC-231: XML Oversized Payloads. Please refer to these CAPECs going forward.</td>
<td align="left">Unknown</td>
<td align="left">Unknown</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">Low</td>
<td align="left">CWE-</td>
</tr>
<tr class="even">
<td align="left">72</td>
<td align="left">CAPEC-63</td>
<td align="left">63</td>
<td align="right">11</td>
<td align="left">10, 18, 22, 25, 31, 34, 41, 42, 46, 50, 70</td>
<td align="left">An adversary embeds malicious scripts in content that will be served to web browsers. The goal of the attack is for the target software, the client-side browser, to execute the script with the users’ privilege level. An attack of this type exploits a programs’ vulnerabilities that are brought on by allowing remote hosts to execute code and scripts. Web browsers, for example, have some simple security controls in place, but if a remote attacker is allowed to execute scripts (through injecting them in to user-generated content like bulletin boards) then these controls may be bypassed. Further, these attacks are very difficult for an end user to detect.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-242</td>
</tr>
<tr class="odd">
<td align="left">183</td>
<td align="left">CAPEC-28</td>
<td align="left">28</td>
<td align="right">11</td>
<td align="left">12, 18, 23, 31, 41, 42, 46, 48, 50, 70, 72</td>
<td align="left">In this attack pattern, the adversary leverages fuzzing to try to identify weaknesses in the system. Fuzzing is a software security and functionality testing method that feeds randomly constructed input to the system and looks for an indication that a failure in response to that input has occurred. Fuzzing treats the system as a black box and is totally free from any preconceptions or assumptions about the system. Fuzzing can help an attacker discover certain assumptions made about user input in the system. Fuzzing gives an attacker a quick way of potentially uncovering some of these assumptions despite not necessarily knowing anything about the internals of the system. These assumptions can then be turned against the system by specially crafting user input that may allow an attacker to achieve their goals.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">CWE-74 , CWE-388, CWE-20</td>
</tr>
<tr class="even">
<td align="left">187</td>
<td align="left">CAPEC-43</td>
<td align="left">43</td>
<td align="right">11</td>
<td align="left">12, 18, 23, 31, 41, 42, 46, 48, 50, 70, 72</td>
<td align="left">An attacker supplies the target software with input data that contains sequences of special characters designed to bypass input validation logic. This exploit relies on the target making multiples passes over the input data and processing a “layer” of special characters with each pass. In this manner, the attacker can disguise input that would otherwise be rejected as invalid by concealing it with layers of special/escape characters that are stripped off by subsequent processing steps. The goal is to first discover cases where the input validation layer executes before one or more parsing layers. That is, user input may go through the following logic in an application: <parser1> –&gt; <input validator> –&gt; <parser2>. In such cases, the attacker will need to provide input that will pass through the input validator, but after passing through parser2, will be converted into something that the input validator was supposed to stop.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="odd">
<td align="left">204</td>
<td align="left">CAPEC-72</td>
<td align="left">72</td>
<td align="right">11</td>
<td align="left">12, 18, 23, 31, 41, 42, 46, 48, 50, 70, 72</td>
<td align="left">This attack targets the encoding of the URL. An attacker can take advantage of the multiple way of encoding an URL and abuse the interpretation of the URL. An URL may contain special character that need special syntax handling in order to be interpreted. Special characters are represented using a percentage character followed by two digits representing the octet code of the original character (%HEX-CODE). For instance US-ASCII space character would be represented with %20. This is often referred as escaped ending or percent-encoding. Since the server decodes the URL from the requests, it may restrict the access to some URL paths by validating and filtering out the URL requests it received. An attacker will try to craft an URL with a sequence of special characters which once interpreted by the server will be equivalent to a forbidden URL. It can be difficult to protect against this attack since the URL can contain other format of encoding such as UTF-8 encoding, Unicode-encoding, etc. The attacker could also subvert the meaning of the URL string request by encoding the data being sent to the server through a GET request. For instance an attacker may subvert the meaning of parameters used in a SQL request and sent through the URL string (See Example section).</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="even">
<td align="left">407</td>
<td align="left">CAPEC-97</td>
<td align="left">97</td>
<td align="right">10</td>
<td align="left">4, 12, 23, 32, 36, 45, 47, 48, 54, 72</td>
<td align="left">Cryptanalysis is a process of finding weaknesses in cryptographic algorithms and using these weaknesses to decipher the ciphertext without knowing the secret key (instance deduction). Sometimes the weakness is not in the cryptographic algorithm itself, but rather in how it is applied that makes cryptanalysis successful. An attacker may have other goals as well, such as: Total Break (finding the secret key), Global Deduction (finding a functionally equivalent algorithm for encryption and decryption that does not require knowledge of the secret key), Information Deduction (gaining some information about plaintexts or ciphertexts that was not previously known) and Distinguishing Algorithm (the attacker has the ability to distinguish the output of the encryption (ciphertext) from a random permutation of bits).</td>
<td align="left">Low</td>
<td align="left">Very High</td>
<td align="right">2</td>
<td align="right">6</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">CAPEC-192</td>
</tr>
<tr class="odd">
<td align="left">785</td>
<td align="left">CAPEC-36</td>
<td align="left">36</td>
<td align="right">9</td>
<td align="left">18, 31, 41, 42, 46, 50, 57, 65, 70</td>
<td align="left">An adversary searches for and invokes interfaces that the target system designers did not intend to be publicly available. If these interfaces fail to authenticate requests the attacker may be able to invoke functionality they are not authorized for.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-113</td>
</tr>
<tr class="even">
<td align="left">12</td>
<td align="left">CAPEC-108</td>
<td align="left">108</td>
<td align="right">8</td>
<td align="left">2, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker uses standard SQL injection methods to inject data into the command line for execution. This could be done directly through misuse of directives such as MSSQL_xp_cmdshell or indirectly through injection of data into the database that would be interpreted as shell commands. Sometime later, an unscrupulous backend application (or could be part of the functionality of the same application) fetches the injected data stored in the database and uses this data as command line arguments without performing proper validation. The malicious data escapes that data plane by spawning new commands to be executed on the host.</td>
<td align="left">Low</td>
<td align="left">Very High</td>
<td align="right">2</td>
<td align="right">6</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">CAPEC-66</td>
</tr>
<tr class="odd">
<td align="left">13</td>
<td align="left">CAPEC-109</td>
<td align="left">109</td>
<td align="right">8</td>
<td align="left">2, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.</td>
<td align="left">Low</td>
<td align="left">High</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">10</td>
<td align="left">Medium</td>
<td align="left">CAPEC-66</td>
</tr>
<tr class="even">
<td align="left">14</td>
<td align="left">CAPEC-110</td>
<td align="left">110</td>
<td align="right">8</td>
<td align="left">2, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker modifies the parameters of the SOAP message that is sent from the service consumer to the service provider to initiate a SQL injection attack. On the service provider side, the SOAP message is parsed and parameters are not properly validated before being used to access a database in a way that does not use parameter binding, thus enabling the attacker to control the structure of the executed SQL query. This pattern describes a SQL injection attack with the delivery mechanism being a SOAP message.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-66</td>
</tr>
<tr class="odd">
<td align="left">16</td>
<td align="left">CAPEC-66</td>
<td align="left">66</td>
<td align="right">8</td>
<td align="left">2, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">This attack exploits target software that constructs SQL statements based on user input. An attacker crafts input strings so that when the target software constructs SQL statements based on the input, the resulting SQL statement performs actions other than those the application intended. SQL Injection results from failure of the application to appropriately validate input. When specially crafted user-controlled input consisting of SQL syntax is used without proper validation as part of SQL queries, it is possible to glean information from the database in ways not envisaged during application design. Depending upon the database and the design of the application, it may also be possible to leverage injection to have the database execute system-related commands of the attackers’ choice. SQL Injection enables an attacker to talk directly to the database, thus bypassing the application completely. Successful injection can cause information disclosure as well as ability to add or modify data in the database. In order to successfully inject SQL and retrieve information from a database, an attacker:</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-248</td>
</tr>
<tr class="even">
<td align="left">68</td>
<td align="left">CAPEC-209</td>
<td align="left">209</td>
<td align="right">8</td>
<td align="left">10, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary’s script may run on the target unsanitized, possibly revealing the victim’s cookies or executing arbitrary script in their browser.</td>
<td align="left">Unknown</td>
<td align="left">Medium</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="left">Low</td>
<td align="left">CAPEC-592</td>
</tr>
<tr class="odd">
<td align="left">69</td>
<td align="left">CAPEC-588</td>
<td align="left">588</td>
<td align="right">8</td>
<td align="left">10, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">This type of attack is a form of Cross-Site Scripting (XSS) where a malicious script is inserted into the client-side HTML being parsed by a web browser. Content served by a vulnerable web application includes script code used to manipulate the Document Object Model (DOM). This script code either does not properly validate input, or does not perform proper output encoding, thus creating an opportunity for an adversary to inject a malicious script launch a XSS attack. A key distinction between other XSS attacks and DOM-based attacks is that in other XSS attacks, the malicious script runs when the vulnerable web page is initially loaded, while a DOM-based attack executes sometime after the page loads. Another distinction of DOM-based attacks is that in some cases, the malicious script is never sent to the vulnerable web server at all. An attack like this is guaranteed to bypass any server-side filtering attempts to protect users.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-63</td>
</tr>
<tr class="even">
<td align="left">70</td>
<td align="left">CAPEC-591</td>
<td align="left">591</td>
<td align="right">8</td>
<td align="left">10, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">This type of attack is a form of Cross-Site Scripting (XSS) where a malicious script is “reflected” off a vulnerable web application and then executed by a victim’s browser. The process starts with an adversary delivering a malicious script to a victim and convincing the victim to send the script to the vulnerable web application. The most common method of this is through a phishing email where the adversary embeds the malicious script with a URL that the victim then clicks on. In processing the subsequent request, the vulnerable web application incorrectly considers the malicious script as valid input and uses it to creates a reposnse that is then sent back to the victim. To launch a successful Reflected XSS attack, an adversary looks for places where user-input is used directly in the generation of a response. This often involves elements that are not expected to host scripts such as image tags (<img>), or the addition of event attibutes such as onload and onmouseover. These elements are often not subject to the same input validation, output encoding, and other content filtering and checking routines.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-63</td>
</tr>
<tr class="odd">
<td align="left">71</td>
<td align="left">CAPEC-592</td>
<td align="left">592</td>
<td align="right">8</td>
<td align="left">10, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">This type of attack is a form of Cross-site Scripting (XSS) where a malicious script is persistenly “stored” within the data storage of a vulnerable web application. Initially presented by an adversary to the vulnerable web application, the malicious script is incorrectly considered valid input and is not properly encoded by the web application. A victim is then convinced to use the web application in a way that creates a response that includes the malicious script. This response is subsequently sent to the victim and the malicious script is executed by the victim’s browser. To launch a successful Stored XSS attack, an adversary looks for places where stored input data is used in the generation of a response. This often involves elements that are not expected to host scripts such as image tags (<img>), or the addition of event attibutes such as onload and onmouseover. These elements are often not subject to the same input validation, output encoding, and other content filtering and checking routines.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-63</td>
</tr>
<tr class="even">
<td align="left">178</td>
<td align="left">CAPEC-230</td>
<td align="left">230</td>
<td align="right">8</td>
<td align="left">18, 31, 41, 42, 46, 50, 54, 70</td>
<td align="left">Applications often need to transform data in and out of the XML format by using an XML parser. It may be possible for an adversary to inject data that may have an adverse effect on the XML parser when it is being processed. By nesting XML data and causing this data to be continuously self-referential, an adversary can cause the XML parser to consume more resources while processing, causing excessive memory consumption and CPU utilization. An adversary’s goal is to leverage parser failure to their advantage. In most cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing. However it may be possible to cause a crash resulting in arbitrary code execution, leading to a jump from the data plane to the control plane [REF-89]. XDoS is most closely associated with web services, SOAP, and Rest, because remote service requesters can post malicious XML payloads to the service provider designed to exhaust the service provider’s memory, CPU, and/or disk space. The main weakness in XDoS is that the service provider generally must inspect, parse, and validate the XML messages to determine routing, workflow, security considerations, and so on. It is exactly these inspection, parsing, and validation routines that XDoS targets. This attack exploits the loosely coupled nature of web services, where the service provider has little to no control over the service requester and any messages the service requester sends.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-130</td>
</tr>
<tr class="odd">
<td align="left">179</td>
<td align="left">CAPEC-231</td>
<td align="left">231</td>
<td align="right">8</td>
<td align="left">18, 31, 41, 42, 46, 50, 54, 70</td>
<td align="left">Applications often need to transform data in and out of serialized data formats, such as XML and YAML, by using a data parser. It may be possible for an adversary to inject data that may have an adverse effect on the parser when it is being processed. By supplying oversized payloads in input vectors that will be processed by the parser, an adversary can cause the parser to consume more resources while processing, causing excessive memory consumption and CPU utilization, and potentially cause execution of arbitrary code. An adversary’s goal is to leverage parser failure to their advantage. DoS is most closely associated with web services, SOAP, and Rest, because remote service requesters can post malicious data payloads to the service provider designed to exhaust the service provider’s memory, CPU, and/or disk space. This attack exploits the loosely coupled nature of web services, where the service provider has little to no control over the service requester and any messages the service requester sends.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-130</td>
</tr>
<tr class="even">
<td align="left">191</td>
<td align="left">CAPEC-473</td>
<td align="left">473</td>
<td align="right">8</td>
<td align="left">18, 31, 36, 41, 42, 46, 50, 70</td>
<td align="left">An attacker generates a message or datablock that causes the recipient to believe that the message or datablock was generated and cryptographically signed by an authoritative or reputable source, misleading a victim or victim operating system into performing malicious actions.</td>
<td align="left">Unknown</td>
<td align="left">Unknown</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">Low</td>
<td align="left">CAPEC-151</td>
</tr>
<tr class="odd">
<td align="left">194</td>
<td align="left">CAPEC-53</td>
<td align="left">53</td>
<td align="right">8</td>
<td align="left">18, 31, 41, 42, 46, 50, 57, 70</td>
<td align="left">If a string is passed through a filter of some kind, then a terminal NULL may not be valid. Using alternate representation of NULL allows an attacker to embed the NULL mid-string while postfixing the proper data so that the filter is avoided. One example is a filter that looks for a trailing slash character. If a string insertion is possible, but the slash must exist, an alternate encoding of NULL in mid-string may be used.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="even">
<td align="left">206</td>
<td align="left">CAPEC-78</td>
<td align="left">78</td>
<td align="right">8</td>
<td align="left">18, 31, 41, 42, 43, 46, 50, 70</td>
<td align="left">This attack targets the use of the backslash in alternate encoding. An attacker can provide a backslash as a leading character and causes a parser to believe that the next character is special. This is called an escape. By using that trick, the attacker tries to exploit alternate ways to encode the same character which leads to filter problems and opens avenues to attack.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="odd">
<td align="left">209</td>
<td align="left">CAPEC-80</td>
<td align="left">80</td>
<td align="right">8</td>
<td align="left">18, 31, 41, 42, 46, 50, 69, 70</td>
<td align="left">This attack is a specific variation on leveraging alternate encodings to bypass validation logic. This attack leverages the possibility to encode potentially harmful input in UTF-8 and submit it to applications not expecting or effective at validating this encoding standard making input filtering difficult. UTF-8 (8-bit UCS/Unicode Transformation Format) is a variable-length character encoding for Unicode. Legal UTF-8 characters are one to four bytes long. However, early version of the UTF-8 specification got some entries wrong (in some cases it permitted overlong characters). UTF-8 encoders are supposed to use the “shortest possible” encoding, but naive decoders may accept encodings that are longer than necessary. According to the RFC 3629, a particularly subtle form of this attack can be carried out against a parser which performs security-critical validity checks against the UTF-8 encoded form of its input, but interprets certain illegal octet sequences as characters.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="even">
<td align="left">213</td>
<td align="left">CAPEC-88</td>
<td align="left">88</td>
<td align="right">8</td>
<td align="left">10, 18, 31, 41, 42, 46, 50, 70</td>
<td align="left">In this type of an attack, an adversary injects operating system commands into existing application functions. An application that uses untrusted input to build command strings is vulnerable. An adversary can leverage OS command injection in an application to elevate privileges, execute arbitrary commands and compromise the underlying operating system.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-248</td>
</tr>
<tr class="odd">
<td align="left">388</td>
<td align="left">CAPEC-50</td>
<td align="left">50</td>
<td align="right">8</td>
<td align="left">18, 31, 33, 41, 42, 46, 50, 70</td>
<td align="left">An attacker may take advantage of the application feature to help users recover their forgotten passwords in order to gain access into the system with the same privileges as the original user. Generally password recovery schemes tend to be weak and insecure. Most of them use only one security question . For instance, mother’s maiden name tends to be a fairly popular one. Unfortunately in many cases this information is not very hard to find, especially if the attacker knows the legitimate user. These generic security questions are also re-used across many applications, thus making them even more insecure. An attacker could for instance overhear a coworker talking to a bank representative at the work place and supplying their mother’s maiden name for verification purposes. An attacker can then try to log in into one of the victim’s accounts, click on “forgot password” and there is a good chance that the security question there will be to provide mother’s maiden name. A weak password recovery scheme totally undermines the effectiveness of a strong password scheme.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-212</td>
</tr>
<tr class="even">
<td align="left">165</td>
<td align="left">CAPEC-101</td>
<td align="left">101</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker can use Server Side Include (SSI) Injection to send code to a web application that then gets executed by the web server. Doing so enables the attacker to achieve similar results to Cross Site Scripting, viz., arbitrary code execution and information disclosure, albeit on a more limited scale, since the SSI directives are nowhere near as powerful as a full-fledged scripting language. Nonetheless, the attacker can conveniently gain access to sensitive files, such as password files, and execute shell commands.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-253</td>
</tr>
<tr class="odd">
<td align="left">166</td>
<td align="left">CAPEC-104</td>
<td align="left">104</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker is able to cause a victim to load content into their web-browser that bypasses security zone controls and gain access to increased privileges to execute scripting code or other web objects such as unsigned ActiveX controls or applets. This is a privilege elevation attack targeted at zone-based web-browser security. In a zone-based model, pages belong to one of a set of zones corresponding to the level of privilege assigned to that page. Pages in an untrusted zone would have a lesser level of access to the system and/or be restricted in the types of executable content it was allowed to invoke. In a cross-zone scripting attack, a page that should be assigned to a less privileged zone is granted the privileges of a more trusted zone. This can be accomplished by exploiting bugs in the browser, exploiting incorrect configuration in the zone controls, through a cross-site scripting attack that causes the attackers’ content to be treated as coming from a more trusted page, or by leveraging some piece of system functionality that is accessible from both the trusted and less trusted zone. This attack differs from “Restful Privilege Escalation” in that the latter correlates to the inadequate securing of RESTful access methods (such as HTTP DELETE) on the server, while cross-zone scripting attacks the concept of security zones as implemented by a browser.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-233</td>
</tr>
<tr class="even">
<td align="left">170</td>
<td align="left">CAPEC-120</td>
<td align="left">120</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">The adversary utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. This may allow the adversary to bypass filters that attempt to detect illegal characters or strings, such as those that might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings, but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.</td>
<td align="left">Low</td>
<td align="left">Medium</td>
<td align="right">2</td>
<td align="right">4</td>
<td align="right">8</td>
<td align="left">Medium</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="odd">
<td align="left">172</td>
<td align="left">CAPEC-135</td>
<td align="left">135</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An adversary includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An adversary can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the adversary can write to the program stack.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-137</td>
</tr>
<tr class="even">
<td align="left">173</td>
<td align="left">CAPEC-136</td>
<td align="left">136</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker manipulates or crafts an LDAP query for the purpose of undermining the security of the target. Some applications use user input to create LDAP queries that are processed by an LDAP server. For example, a user might provide their username during authentication and the username might be inserted in an LDAP query during the authentication process. An attacker could use this input to inject additional commands into an LDAP query that could disclose sensitive information. For example, entering a * in the aforementioned query might return information about all users on the system. This attack is very similar to an SQL injection attack in that it manipulates a query to gather additional information or coerce a particular return value.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-248</td>
</tr>
<tr class="odd">
<td align="left">175</td>
<td align="left">CAPEC-182</td>
<td align="left">182</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker tricks a victim to execute malicious flash content that executes commands or makes flash calls specified by the attacker. One example of this attack is cross-site flashing, an attacker controlled parameter to a reference call loads from content specified by the attacker.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">CAPEC-137</td>
</tr>
<tr class="even">
<td align="left">181</td>
<td align="left">CAPEC-250</td>
<td align="left">250</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker utilizes crafted XML user-controllable input to probe, attack, and inject data into the XML database, using techniques similar to SQL injection. The user-controllable input can allow for unauthorized viewing of data, bypassing authentication or the front-end application for direct XML database access, and possibly altering database information.</td>
<td align="left">High</td>
<td align="left">Unknown</td>
<td align="right">4</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="left">Low</td>
<td align="left">CAPEC-248</td>
</tr>
<tr class="odd">
<td align="left">182</td>
<td align="left">CAPEC-267</td>
<td align="left">267</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An adversary leverages the possibility to encode potentially harmful input or content used by applications such that the applications are ineffective at validating this encoding standard.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-153</td>
</tr>
<tr class="even">
<td align="left">192</td>
<td align="left">CAPEC-484</td>
<td align="left">484</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">This attack pattern has been deprecated as it a generalization of CAPEC-230: XML Nested Payloads and CAPEC-231: XML Oversized Payloads. Please refer to these CAPECs going forward.</td>
<td align="left">Unknown</td>
<td align="left">Unknown</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">Low</td>
<td align="left">CWE-</td>
</tr>
<tr class="odd">
<td align="left">193</td>
<td align="left">CAPEC-52</td>
<td align="left">52</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker embeds one or more null bytes in input to the target software. This attack relies on the usage of a null-valued byte as a string terminator in many environments. The goal is for certain components of the target software to stop processing the input when it encounters the null byte(s).</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="even">
<td align="left">203</td>
<td align="left">CAPEC-71</td>
<td align="left">71</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker may provide a Unicode string to a system component that is not Unicode aware and use that to circumvent the filter or cause the classifying mechanism to fail to properly understanding the request. That may allow the attacker to slip malicious data past the content filter and/or possibly cause the application to route the request incorrectly.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-267</td>
</tr>
<tr class="odd">
<td align="left">210</td>
<td align="left">CAPEC-81</td>
<td align="left">81</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">Web Logs Tampering attacks involve an attacker injecting, deleting or otherwise tampering with the contents of web logs typically for the purposes of masking other malicious behavior. Additionally, writing malicious data to log files may target jobs, filters, reports, and other agents that process the logs in an asynchronous attack pattern. This pattern of attack is similar to “Log Injection-Tampering-Forging” except that in this case, the attack is targeting the logs of the web server and not the application.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-268</td>
</tr>
<tr class="even">
<td align="left">211</td>
<td align="left">CAPEC-83</td>
<td align="left">83</td>
<td align="right">7</td>
<td align="left">18, 31, 41, 42, 46, 50, 70</td>
<td align="left">An attacker can craft special user-controllable input consisting of XPath expressions to inject the XML database and bypass authentication or glean information that they normally would not be able to. XPath Injection enables an attacker to talk directly to the XML database, thus bypassing the application completely. XPath Injection results from the failure of an application to properly sanitize input used as part of dynamic XPath expressions used to query an XML database.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-250</td>
</tr>
<tr class="odd">
<td align="left">224</td>
<td align="left">CAPEC-57</td>
<td align="left">57</td>
<td align="right">7</td>
<td align="left">12, 22, 23, 25, 34, 48, 72</td>
<td align="left">This attack utilizes a REST(REpresentational State Transfer)-style applications’ trust in the system resources and environment to obtain sensitive data once SSL is terminated. Rest applications premise is that they leverage existing infrastructure to deliver web services functionality. An example of this is a Rest application that uses HTTP Get methods and receives a HTTP response with an XML document. These Rest style web services are deployed on existing infrastructure such as Apache and IIS web servers with no SOAP stack required. Unfortunately from a security standpoint, there frequently is no interoperable identity security mechanism deployed, so Rest developers often fall back to SSL to deliver security. In large data centers, SSL is typically terminated at the edge of the network - at the firewall, load balancer, or router. Once the SSL is terminated the HTTP request is in the clear (unless developers have hashed or encrypted the values, but this is rare). The attacker can utilize a sniffer such as Wireshark to snapshot the credentials, such as username and password that are passed in the clear once SSL is terminated. Once the attacker gathers these credentials, they can submit requests to the web service provider just as authorized user do. There is not typically an authentication on the client side, beyond what is passed in the request itself so once this is compromised, then this is generally sufficient to compromise the service’s authentication scheme.</td>
<td align="left">Medium</td>
<td align="left">Very High</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="right">18</td>
<td align="left">Critical</td>
<td align="left">CAPEC-157</td>
</tr>
<tr class="even">
<td align="left">227</td>
<td align="left">CAPEC-94</td>
<td align="left">94</td>
<td align="right">7</td>
<td align="left">12, 22, 23, 25, 34, 48, 72</td>
<td align="left">This type of attack targets the communication between two components (typically client and server). The attacker places themself in the communication channel between the two components. Whenever one component attempts to communicate with the other (data flow, authentication challenges, etc.), the data first goes to the attacker, who has the opportunity to observe or alter it, and it is then passed on to the other component as if it was never observed. This interposition is transparent leaving the two compromised components unaware of the potential corruption or leakage of their communications. The potential for Man-in-the-Middle attacks yields an implicit lack of trust in communication or identify between two components. MITM attacks differ from sniffing attacks since they often modify the communications prior to delivering it to the intended recipient. These attacks also differ from interception attacks since they may forward the sender’s original unmodified data, after copying it, instead of keeping it for themselves.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">T1185</td>
</tr>
<tr class="odd">
<td align="left">137</td>
<td align="left">CAPEC-60</td>
<td align="left">60</td>
<td align="right">6</td>
<td align="left">12, 23, 36, 48, 69, 72</td>
<td align="left">This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">T1134.002, T1134.003, T1550.004</td>
</tr>
<tr class="even">
<td align="left">821</td>
<td align="left">CAPEC-61</td>
<td align="left">61</td>
<td align="right">6</td>
<td align="left">12, 23, 36, 48, 69, 72</td>
<td align="left">The attacker induces a client to establish a session with the target software using a session identifier provided by the attacker. Once the user successfully authenticates to the target software, the attacker uses the (now privileged) session identifier in their own transactions. This attack leverages the fact that the target software either relies on client-generated session identifiers or maintains the same session identifiers after privilege elevation.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-593</td>
</tr>
<tr class="odd">
<td align="left">19</td>
<td align="left">CAPEC-147</td>
<td align="left">147</td>
<td align="right">5</td>
<td align="left">4, 32, 45, 47, 54</td>
<td align="left">An attacker initiates a resource depletion attack where a large number of small XML messages are delivered at a sufficiently rapid rate to cause a denial of service or crash of the target. Transactions such as repetitive SOAP transactions can deplete resources faster than a simple flooding attack because of the additional resources used by the SOAP protocol and the resources necessary to process SOAP messages. The transactions used are immaterial as long as they cause resource utilization on the target. In other words, this is a normal flooding attack augmented by using messages that will require extra processing on the target.</td>
<td align="left">Low</td>
<td align="left">Medium</td>
<td align="right">2</td>
<td align="right">4</td>
<td align="right">8</td>
<td align="left">Medium</td>
<td align="left">CAPEC-528</td>
</tr>
<tr class="even">
<td align="left">20</td>
<td align="left">CAPEC-197</td>
<td align="left">197</td>
<td align="right">5</td>
<td align="left">4, 32, 45, 47, 54</td>
<td align="left">An attacker submits an XML document to a target application where the XML document uses nested entity expansion to produce an excessively large output XML. XML allows the definition of macro-like structures that can be used to simplify the creation of complex structures. However, this capability can be abused to create excessive demands on a processor’s CPU and memory. A small number of nested expansions can result in an exponential growth in demands on memory.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">CAPEC-230</td>
</tr>
<tr class="odd">
<td align="left">521</td>
<td align="left">CAPEC-76</td>
<td align="left">76</td>
<td align="right">5</td>
<td align="left">12, 23, 43, 48, 72</td>
<td align="left">An attacker manipulates inputs to the target software which the target software passes to file system calls in the OS. The goal is to gain access to, and perhaps modify, areas of the file system that the target software did not intend to be accessible.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-126</td>
</tr>
<tr class="even">
<td align="left">816</td>
<td align="left">CAPEC-17</td>
<td align="left">17</td>
<td align="right">5</td>
<td align="left">12, 23, 48, 69, 72</td>
<td align="left">An attack of this type exploits a system’s configuration that allows an attacker to either directly access an executable file, for example through shell access; or in a possible worst case allows an attacker to upload a file and then execute it. Web servers, ftp servers, and message oriented middleware systems which have many integration points are particularly vulnerable, because both the programmers and the administrators must be in synch regarding the interfaces and the correct privileges for each interface.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">T1574.010</td>
</tr>
<tr class="odd">
<td align="left">85</td>
<td align="left">CAPEC-116</td>
<td align="left">116</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary actively probes the target in a manner that is designed to solicit information that could be leveraged for malicious purposes. This is achieved by exploring the target via ordinary interactions for the purpose of gathering intelligence about the target, or by sending data that is syntactically invalid or non-standard in an attempt to produce a response that contains the desired data. As a result of these interactions, the adversary is able to obtain information from the target that aids the attacker in making inferences about its security, configuration, or potential vulnerabilities. Examplar exchanges with the target may trigger unhandled exceptions or verbose error messages that reveal information like stack traces, configuration information, path information, or database design. This type of attack also includes the manipulation of query strings in a URI to produce invalid SQL queries, or by trying alternative path values in the hope that the server will return useful information.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">CWE-200 , CWE-1243</td>
</tr>
<tr class="even">
<td align="left">86</td>
<td align="left">CAPEC-117</td>
<td align="left">117</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position themself so as to observe explicit data channels (e.g. network traffic) and read the content. However, this attack differs from a Man-In-the-Middle (MITM) attack, as the adversary does not alter the content of the communications nor forward data to the intended recipient.</td>
<td align="left">Low</td>
<td align="left">Medium</td>
<td align="right">2</td>
<td align="right">4</td>
<td align="right">8</td>
<td align="left">Medium</td>
<td align="left">CWE-319</td>
</tr>
<tr class="odd">
<td align="left">88</td>
<td align="left">CAPEC-169</td>
<td align="left">169</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary engages in probing and exploration activities to identify constituents and properties of the target. Footprinting is a general term to describe a variety of information gathering techniques, often used by attackers in preparation for some attack. It consists of using tools to learn as much as possible about the composition, configuration, and security mechanisms of the targeted application, system or network. Information that might be collected during a footprinting effort could include open ports, applications and their versions, network topology, and similar information. Although similar to fingerprinting, footprinting aims to get a more holistic view of a system or network, whereas fingerprinting is more targeted to a specific application or operating system. While footprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.</td>
<td align="left">High</td>
<td align="left">Very Low</td>
<td align="right">4</td>
<td align="right">2</td>
<td align="right">8</td>
<td align="left">Medium</td>
<td align="left">T1217</td>
</tr>
<tr class="even">
<td align="left">90</td>
<td align="left">CAPEC-224</td>
<td align="left">224</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary compares output from a target system to known indicators that uniquely identify specific details about the target. Most commonly, fingerprinting is done to determine operating system and application versions. Fingerprinting can be done passively as well as actively. Fingerprinting by itself is not usually detrimental to the target. However, the information gathered through fingerprinting often enables an adversary to discover existing weaknesses in the target.</td>
<td align="left">High</td>
<td align="left">Very Low</td>
<td align="right">4</td>
<td align="right">2</td>
<td align="right">8</td>
<td align="left">Medium</td>
<td align="left">CWE-200</td>
</tr>
<tr class="odd">
<td align="left">91</td>
<td align="left">CAPEC-285</td>
<td align="left">285</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary sends out an ICMP Type 8 Echo Request, commonly known as a ‘Ping’, in order to determine if a target system is responsive. If the request is not blocked by a firewall or ACL, the target host will respond with an ICMP Type 0 Echo Reply datagram. This type of exchange is usually referred to as a ‘Ping’ due to the Ping utility present in almost all operating systems. Ping, as commonly implemented, allows a user to test for alive hosts, measure round-trip time, and measure the percentage of packet loss. Performing this operation for a range of hosts on the network is known as a ‘Ping Sweep’. While the Ping utility is useful for small-scale host discovery, it was not designed for rapid or efficient host discovery over large network blocks. Other scanning utilities have been created that make ICMP ping sweeps easier to perform. Most networks filter ingress ICMP Type 8 messages for security reasons. Various other methods of performing ping sweeps have developed as a result. It is important to recognize the key security goal of the adversary is to discover if an IP address is alive, or has a responsive host. To this end, virtually any type of ICMP message, as defined by RFC 792 is useful. An adversary can cycle through various types of ICMP messages to determine if holes exist in the firewall configuration. When ICMP ping sweeps fail to discover hosts, other protocols can be used for the same purpose, such as TCP SYN or ACK segments, UDP datagrams sent to closed ports, etc.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-292</td>
</tr>
<tr class="even">
<td align="left">92</td>
<td align="left">CAPEC-287</td>
<td align="left">287</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses a SYN scan to determine the status of ports on the remote target. SYN scanning is the most common type of port scanning that is used because of its many advantages and few drawbacks. As a result, novice attackers tend to overly rely on the SYN scan while performing system reconnaissance. As a scanning method, the primary advantages of SYN scanning are its universality and speed. RFC 793 defines the required behavior of any TCP/IP device in that an incoming connection request begins with a SYN packet, which in turn must be followed by a SYN/ACK packet from the receiving service. For this reason, like TCP Connect scanning, SYN scanning works against any TCP stack. Unlike TCP Connect scanning, it is possible to scan thousands of ports per second using this method. This type of scanning is usually referred to as ‘half-open’ scanning because it does not complete the three-way handshake. The scanning rate is extremely fast because no time is wasted completing the handshake or tearing down the connection. This technique allows an attacker to scan through stateful firewalls due to the common configuration that TCP SYN segments for a new connection will be allowed for almost any port. TCP SYN scanning can also immediately detect 3 of the 4 important types of port status: open, closed, and filtered.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="odd">
<td align="left">93</td>
<td align="left">CAPEC-290</td>
<td align="left">290</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary enumerates the MX records for a given via a DNS query. This type of information gathering returns the names of mail servers on the network. Mail servers are often not exposed to the Internet but are located within the DMZ of a network protected by a firewall. A side effect of this configuration is that enumerating the MX records for an organization my reveal the IP address of the firewall or possibly other internal systems. Attackers often resort to MX record enumeration when a DNS Zone Transfer is not possible.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-309</td>
</tr>
<tr class="even">
<td align="left">94</td>
<td align="left">CAPEC-291</td>
<td align="left">291</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An attacker exploits a DNS misconfiguration that permits a ZONE transfer. Some external DNS servers will return a list of IP address and valid hostnames. Under certain conditions, it may even be possible to obtain Zone data about the organization’s internal network. When successful the attacker learns valuable information about the topology of the target organization, including information about particular servers, their role within the IT structure, and possibly information about the operating systems running upon the network. This is configuration dependent behavior so it may also be required to search out multiple DNS servers while attempting to find one with ZONE transfers allowed.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-309</td>
</tr>
<tr class="odd">
<td align="left">95</td>
<td align="left">CAPEC-292</td>
<td align="left">292</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary sends a probe to an IP address to determine if the host is alive. Host discovery is one of the earliest phases of network reconnaissance. The adversary usually starts with a range of IP addresses belonging to a target network and uses various methods to determine if a host is present at that IP address. Host discovery is usually referred to as ‘Ping’ scanning using a sonar analogy. The goal is to send a packet through to the IP address and solicit a response from the host. As such, a ‘ping’ can be virtually any crafted packet whatsoever, provided the adversary can identify a functional host based on its response. An attack of this nature is usually carried out with a ‘ping sweep,’ where a particular kind of ping is sent to a range of IP addresses.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">T1018</td>
</tr>
<tr class="even">
<td align="left">96</td>
<td align="left">CAPEC-293</td>
<td align="left">293</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses a traceroute utility to map out the route which data flows through the network in route to a target destination. Tracerouting can allow the adversary to construct a working topology of systems and routers by listing the systems through which data passes through on their way to the targeted machine. This attack can return varied results depending upon the type of traceroute that is performed. Traceroute works by sending packets to a target while incrementing the Time-to-Live field in the packet header. As the packet traverses each hop along its way to the destination, its TTL expires generating an ICMP diagnostic message that identifies where the packet expired. Traditional techniques for tracerouting involved the use of ICMP and UDP, but as more firewalls began to filter ingress ICMP, methods of traceroute using TCP were developed.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-309</td>
</tr>
<tr class="odd">
<td align="left">97</td>
<td align="left">CAPEC-294</td>
<td align="left">294</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary sends an ICMP Type 17 Address Mask Request to gather information about a target’s networking configuration. ICMP Address Mask Requests are defined by RFC-950, “Internet Standard Subnetting Procedure.” An Address Mask Request is an ICMP type 17 message that triggers a remote system to respond with a list of its related subnets, as well as its default gateway and broadcast address via an ICMP type 18 Address Mask Reply datagram. Gathering this type of information helps the adversary plan router-based attacks as well as denial-of-service attacks against the broadcast address. Many modern operating systems will not respond to ICMP type 17 messages for security reasons. Determining whether a system or router will respond to an ICMP Address Mask Request helps the adversary determine operating system or firmware version. Additionally, because these types of messages are rare, they are easily spotted by intrusion detection systems. Many ICMP scanning tools support IP spoofing to help conceal the origin of the actual request among a storm of similar ICMP messages. It is a common practice for border firewalls and gateways to be configured to block ingress ICMP type 17 and egress ICMP type 18 messages.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-292</td>
</tr>
<tr class="even">
<td align="left">98</td>
<td align="left">CAPEC-295</td>
<td align="left">295</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This pattern of attack leverages standard requests to learn the exact time associated with a target system. An adversary may be able to use the timestamp returned from the target to attack time-based security algorithms, such as random number generators, or time-based authentication mechanisms.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">T1124</td>
</tr>
<tr class="odd">
<td align="left">99</td>
<td align="left">CAPEC-296</td>
<td align="left">296</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary sends an ICMP Information Request to a host to determine if it will respond to this deprecated mechanism. ICMP Information Requests are a deprecated message type. Information Requests were originally used for diskless machines to automatically obtain their network configuration, but this message type has been superseded by more robust protocol implementations like DHCP.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-292</td>
</tr>
<tr class="even">
<td align="left">100</td>
<td align="left">CAPEC-297</td>
<td align="left">297</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary sends a TCP segment with the ACK flag set to a remote host for the purpose of determining if the host is alive. This is one of several TCP ‘ping’ types. The RFC 793 expected behavior for a service is to respond with a RST ‘reset’ packet to any unsolicited ACK segment that is not part of an existing connection. So by sending an ACK segment to a port, the adversary can identify that the host is alive by looking for a RST packet. Typically, a remote server will respond with a RST regardless of whether a port is open or closed. In this way, TCP ACK pings cannot discover the state of a remote port because the behavior is the same in either case. The firewall will look up the ACK packet in its state-table and discard the segment because it does not correspond to any active connection. A TCP ACK Ping can be used to discover if a host is alive via RST response packets sent from the host.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-292</td>
</tr>
<tr class="odd">
<td align="left">101</td>
<td align="left">CAPEC-298</td>
<td align="left">298</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary sends a UDP datagram to the remote host to determine if the host is alive. If a UDP datagram is sent to an open UDP port there is very often no response, so a typical strategy for using a UDP ping is to send the datagram to a random high port on the target. The goal is to solicit an ‘ICMP port unreachable’ message from the target, indicating that the host is alive. UDP pings are useful because some firewalls are not configured to block UDP datagrams sent to strange or typically unused ports, like ports in the 65K range. Additionally, while some firewalls may filter incoming ICMP, weaknesses in firewall rule-sets may allow certain types of ICMP (host unreachable, port unreachable) which are useful for UDP ping attempts.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-292</td>
</tr>
<tr class="even">
<td align="left">102</td>
<td align="left">CAPEC-299</td>
<td align="left">299</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses TCP SYN packets as a means towards host discovery. Typical RFC 793 behavior specifies that when a TCP port is open, a host must respond to an incoming SYN “synchronize” packet by completing stage two of the ‘three-way handshake’ - by sending an SYN/ACK in response. When a port is closed, RFC 793 behavior is to respond with a RST “reset” packet. This behavior can be used to ‘ping’ a target to see if it is alive by sending a TCP SYN packet to a port and then looking for a RST or an ACK packet in response. Due to the different responses from open and closed ports, SYN packets can be used to determine the remote state of the port. A TCP SYN ping is also useful for discovering alive hosts protected by a stateful firewall. In cases where a specific firewall rule does not block access to a port, a SYN packet can pass through the firewall to the host and solicit a response from either an open or closed port. When a stateful firewall is present, SYN pings are preferable to ACK pings because a stateful firewall will typically drop all unsolicited ACK packets as they are not part of an existing or new connection. TCP SYN pings often fail when a stateless ACL or firewall is configured to blanket-filter incoming packets to a port. The firewall device will discard any SYN packets to a blocked port. Often, an adversary will alternate between SYN and ACK pings to discover if a host is alive.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-292</td>
</tr>
<tr class="odd">
<td align="left">103</td>
<td align="left">CAPEC-300</td>
<td align="left">300</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses a combination of techniques to determine the state of the ports on a remote target. Any service or application available for TCP or UDP networking will have a port open for communications over the network. Although common services have assigned port numbers, services and applications can run on arbitrary ports. Additionally, port scanning is complicated by the potential for any machine to have up to 65535 possible UDP or TCP services. The goal of port scanning is often broader than identifying open ports, but also give the adversary information concerning the firewall configuration. Depending upon the method of scanning that is used, the process can be stealthy or more obtrusive, the latter being more easily detectable due to the volume of packets involved, anomalous packet traits, or system logging. Typical port scanning activity involves sending probes to a range of ports and observing the responses. There are four port statuses that this type of attack aims to identify: open, closed, filtered, and unfiltered. For strategic purposes it is useful for an adversary to distinguish between an open port that is protected by a filter vs. a closed port that is not protected by a filter. Making these fine grained distinctions is requires certain scan types. Collecting this type of information tells the adversary which ports can be attacked directly, which must be attacked with filter evasion techniques like fragmentation, source port scans, and which ports are unprotected (i.e. not firewalled) but aren’t hosting a network service. An adversary often combines various techniques in order to gain a more complete picture of the firewall filtering mechanisms in place for a host.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">T1046</td>
</tr>
<tr class="even">
<td align="left">104</td>
<td align="left">CAPEC-301</td>
<td align="left">301</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses full TCP connection attempts to determine if a port is open on the target system. The scanning process involves completing a ‘three-way handshake’ with a remote port, and reports the port as closed if the full handshake cannot be established. An advantage of TCP connect scanning is that it works against any TCP/IP stack. RFC 793 defines how TCP connections are established and torn down. TCP connect scanning commonly involves establishing a full connection, and then subsequently tearing it down, and therefore involves sending a significant number of packets to each port that is scanned. Compared to other types of scans, a TCP Connect scan is slow and methodical. This type of scanning causes considerable noise in system logs and can be spotted by IDS/IPS systems. TCP Connect scanning can detect when a port is open by completing the three-way handshake, but it cannot distinguish a port that is unfiltered with no service running on it from a port that is filtered by a firewall but contains an active service. Due to the significant volume of packets exchanged per port, TCP connect scanning can become very time consuming (performing a full TCP connect scan against a host can take multiple days). Generally, it is not used as a method for performing a comprehensive port scan, but is reserved for checking a short list of common ports.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="odd">
<td align="left">105</td>
<td align="left">CAPEC-302</td>
<td align="left">302</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses a TCP FIN scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the FIN bit set in the packet header. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow the adversary to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. In addition to its relative speed in comparison with other types of scans, the major advantage a TCP FIN Scan is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to ‘build’ a connection. FIN packets, like out-of-state ACK packets, tend to pass through such devices undetected. FIN scanning is still relatively stealthy as the packets tend to blend in with the background noise on a network link.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="even">
<td align="left">106</td>
<td align="left">CAPEC-303</td>
<td align="left">303</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses a TCP XMAS scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with all possible flags set in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. In addition to its relative speed when compared with other types of scans, its major advantage is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to ‘build’ a connection. XMAS packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, XMAS scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, XMAS scans are flagged by almost all intrusion prevention or intrusion detection systems.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="odd">
<td align="left">107</td>
<td align="left">CAPEC-304</td>
<td align="left">304</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses a TCP NULL scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with no flags in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. In addition to being fast, the major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to ‘build’ a connection. NULL packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, NULL scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, NULL scans are flagged by almost all intrusion prevention or intrusion detection systems.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="even">
<td align="left">108</td>
<td align="left">CAPEC-305</td>
<td align="left">305</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses TCP ACK segments to gather information about firewall or ACL configuration. The purpose of this type of scan is to discover information about filter configurations rather than port state. This type of scanning is rarely useful alone, but when combined with SYN scanning, gives a more complete picture of the type of firewall rules that are present. When a TCP ACK segment is sent to a closed port, or sent out-of-sync to a listening port, the RFC 793 expected behavior is for the device to respond with a RST. Getting RSTs back in response to a ACK scan gives the attacker useful information that can be used to infer the type of firewall present. Stateful firewalls will discard out-of-sync ACK packets, leading to no response. When this occurs the port is marked as filtered. When RSTs are received in response, the ports are marked as unfiltered, as the ACK packets solicited the expected behavior from a port. When combined with SYN techniques an attacker can gain a more complete picture of which types of packets get through to a host and thereby map out its firewall rule-set. ACK scanning, when combined with SYN scanning, also allows the adversary to analyze whether a firewall is stateful or non-stateful (described in notes). TCP ACK Scans are somewhat faster and more stealthy than other types of scans but often requires rather sophisticated analysis by an experienced person. A skilled adversary may use this method to map out firewall rules, but the results of ACK scanning will be less useful to a novice.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="odd">
<td align="left">109</td>
<td align="left">CAPEC-306</td>
<td align="left">306</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary engages in TCP Window scanning to analyze port status and operating system type. TCP Window scanning uses the ACK scanning method but examine the TCP Window Size field of response RST packets to make certain inferences. While TCP Window Scans are fast and relatively stealthy, they work against fewer TCP stack implementations than any other type of scan. Some operating systems return a positive TCP window size when a RST packet is sent from an open port, and a negative value when the RST originates from a closed port. TCP Window scanning is one of the most complex scan types, and its results are difficult to interpret. Window scanning alone rarely yields useful information, but when combined with other types of scanning is more useful. It is a generally more reliable means of making inference about operating system versions than port status.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="even">
<td align="left">110</td>
<td align="left">CAPEC-307</td>
<td align="left">307</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary scans for RPC services listing on a Unix/Linux host. This type of scan can be obtained via native operating system utilities or via port scanners like nmap. When performed by a scanner, an RPC datagram is sent to a list of UDP ports and the response is recorded. Particular types of responses can be indicative of well-known RPC services running on a UDP port. Direct RPC scans that bypass portmapper/sunrpc are typically slow compare to other scan types, are easily detected by IPS/IDS systems, and can only detect open ports when an RPC service responds. ICMP diagnostic message responses can help identify closed ports, however filtered and unfiltered ports cannot be identified through TCP RPC scans. There are two general approaches to RPC scanning: One is to use a native operating system utility, or script, to query the portmapper/rpcbind application running on port 111. Portmapper will return a list of registered RPC services. Alternately, one can use a port scanner or script to scan for RPC services directly. Discovering RPC services gives the attacker potential targets to attack, as some RPC services are insecure by default.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="odd">
<td align="left">111</td>
<td align="left">CAPEC-308</td>
<td align="left">308</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary engages in UDP scanning to gather information about UDP port status on the target system. UDP scanning methods involve sending a UDP datagram to the target port and looking for evidence that the port is closed. Open UDP ports usually do not respond to UDP datagrams as there is no stateful mechanism within the protocol that requires building or establishing a session. Responses to UDP datagrams are therefore application specific and cannot be relied upon as a method of detecting an open port. UDP scanning relies heavily upon ICMP diagnostic messages in order to determine the status of a remote port. During a UDP scan, a datagram is sent to a target port. If an ‘ICMP Type 3 Port unreachable’ error message is returned then the port is considered closed. Different types of ICMP messages can indicate a filtered port. UDP scanning is slower than TCP scanning. The protocol characteristics of UDP make port scanning inherently more difficult than with TCP, as well as dependent upon ICMP for accurate scanning. Due to ambiguities that can arise between open ports and filtered ports, UDP scanning results often require a high degree of interpretation and further testing to refine. In general, UDP scanning results are less reliable or accurate than TCP-based scanning.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-300</td>
</tr>
<tr class="even">
<td align="left">112</td>
<td align="left">CAPEC-309</td>
<td align="left">309</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary engages in scanning activities to map network nodes, hosts, devices, and routes. Adversaries usually perform this type of network reconnaissance during the early stages of attack against an external network. Many types of scanning utilities are typically employed, including ICMP tools, network mappers, port scanners, and route testing utilities such as traceroute.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">T1016</td>
</tr>
<tr class="odd">
<td align="left">113</td>
<td align="left">CAPEC-310</td>
<td align="left">310</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An attacker engages in scanning activity to find vulnerable software versions or types, such as operating system versions or network services. Vulnerable or exploitable network configurations, such as improperly firewalled systems, or misconfigured systems in the DMZ or external network, provide windows of opportunity for an attacker. Common types of vulnerable software include unpatched operating systems or services (e.g FTP, Telnet, SMTP, SNMP) running on open ports that the attacker has identified. Attackers usually begin probing for vulnerable software once the external network has been port scanned and potential targets have been revealed.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-541</td>
</tr>
<tr class="even">
<td align="left">114</td>
<td align="left">CAPEC-312</td>
<td align="left">312</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary engages in activity to detect the operating system or firmware version of a remote target by interrogating a device, server, or platform with a probe designed to solicit behavior that will reveal information about the operating systems or firmware in the environment. Operating System detection is possible because implementations of common protocols (Such as IP or TCP) differ in distinct ways. While the implementation differences are not sufficient to ‘break’ compatibility with the protocol the differences are detectable because the target will respond in unique ways to specific probing activity that breaks the semantic or logical rules of packet construction for a protocol. Different operating systems will have a unique response to the anomalous input, providing the basis to fingerprint the OS behavior. This type of OS fingerprinting can distinguish between operating system types and versions.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">T1082</td>
</tr>
<tr class="odd">
<td align="left">115</td>
<td align="left">CAPEC-313</td>
<td align="left">313</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary engages in activity to detect the version or type of OS software in a an environment by passively monitoring communication between devices, nodes, or applications. Passive techniques for operating system detection send no actual probes to a target, but monitor network or client-server communication between nodes in order to identify operating systems based on observed behavior as compared to a database of known signatures or values. While passive OS fingerprinting is not usually as reliable as active methods, it is generally better able to evade detection.</td>
<td align="left">High</td>
<td align="left">Low</td>
<td align="right">4</td>
<td align="right">3</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">CAPEC-224</td>
</tr>
<tr class="even">
<td align="left">116</td>
<td align="left">CAPEC-317</td>
<td align="left">317</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe analyzes the IP ‘ID’ field sequence number generation algorithm of a remote host. Operating systems generate IP ‘ID’ numbers differently, allowing an attacker to identify the operating system of the host by examining how is assigns ID numbers when generating response packets. RFC 791 does not specify how ID numbers are chosen or their ranges, so ID sequence generation differs from implementation to implementation. There are two kinds of IP ‘ID’ sequence number analysis - IP ‘ID’ Sequencing: analyzing the IP ‘ID’ sequence generation algorithm for one protocol used by a host and Shared IP ‘ID’ Sequencing: analyzing the packet ordering via IP ‘ID’ values spanning multiple protocols, such as between ICMP and TCP.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="odd">
<td align="left">117</td>
<td align="left">CAPEC-318</td>
<td align="left">318</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe tests to determine if the remote host echoes back the IP ‘ID’ value from the probe packet. An attacker sends a UDP datagram with an arbitrary IP ‘ID’ value to a closed port on the remote host to observe the manner in which this bit is echoed back in the ICMP error message. The identification field (ID) is typically utilized for reassembling a fragmented packet. Some operating systems or router firmware reverse the bit order of the ID field when echoing the IP Header portion of the original datagram within an ICMP error message.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="even">
<td align="left">118</td>
<td align="left">CAPEC-319</td>
<td align="left">319</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe tests to determine if the remote host echoes back the IP ‘DF’ (Don’t Fragment) bit in a response packet. An attacker sends a UDP datagram with the DF bit set to a closed port on the remote host to observe whether the ‘DF’ bit is set in the response packet. Some operating systems will echo the bit in the ICMP error message while others will zero out the bit in the response packet.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="odd">
<td align="left">119</td>
<td align="left">CAPEC-320</td>
<td align="left">320</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe examines the remote server’s implementation of TCP timestamps. Not all operating systems implement timestamps within the TCP header, but when timestamps are used then this provides the attacker with a means to guess the operating system of the target. The attacker begins by probing any active TCP service in order to get response which contains a TCP timestamp. Different Operating systems update the timestamp value using different intervals. This type of analysis is most accurate when multiple timestamp responses are received and then analyzed. TCP timestamps can be found in the TCP Options field of the TCP header.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="even">
<td align="left">120</td>
<td align="left">CAPEC-321</td>
<td align="left">321</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe tests the target system’s assignment of TCP sequence numbers. One common way to test TCP Sequence Number generation is to send a probe packet to an open port on the target and then compare the how the Sequence Number generated by the target relates to the Acknowledgement Number in the probe packet. Different operating systems assign Sequence Numbers differently, so a fingerprint of the operating system can be obtained by categorizing the relationship between the acknowledgement number and sequence number as follows: 1) the Sequence Number generated by the target is Zero, 2) the Sequence Number generated by the target is the same as the acknowledgement number in the probe, 3) the Sequence Number generated by the target is the acknowledgement number plus one, or 4) the Sequence Number is any other non-zero number.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="odd">
<td align="left">121</td>
<td align="left">CAPEC-322</td>
<td align="left">322</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe sends a number of TCP SYN packets to an open port of a remote machine. The Initial Sequence Number (ISN) in each of the SYN/ACK response packets is analyzed to determine the smallest number that the target host uses when incrementing sequence numbers. This information can be useful for identifying an operating system because particular operating systems and versions increment sequence numbers using different values. The result of the analysis is then compared against a database of OS behaviors to determine the OS type and/or version.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="even">
<td align="left">122</td>
<td align="left">CAPEC-323</td>
<td align="left">323</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS detection probe measures the average rate of initial sequence number increments during a period of time. Sequence numbers are incremented using a time-based algorithm and are susceptible to a timing analysis that can determine the number of increments per unit time. The result of this analysis is then compared against a database of operating systems and versions to determine likely operation system matches.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="odd">
<td align="left">123</td>
<td align="left">CAPEC-324</td>
<td align="left">324</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This type of operating system probe attempts to determine an estimate for how predictable the sequence number generation algorithm is for a remote host. Statistical techniques, such as standard deviation, can be used to determine how predictable the sequence number generation is for a system. This result can then be compared to a database of operating system behaviors to determine a likely match for operating system and version.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="even">
<td align="left">124</td>
<td align="left">CAPEC-325</td>
<td align="left">325</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe checks to see if the remote host supports explicit congestion notification (ECN) messaging. ECN messaging was designed to allow routers to notify a remote host when signal congestion problems are occurring. Explicit Congestion Notification messaging is defined by RFC 3168. Different operating systems and versions may or may not implement ECN notifications, or may respond uniquely to particular ECN flag types.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="odd">
<td align="left">125</td>
<td align="left">CAPEC-326</td>
<td align="left">326</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe checks the initial TCP Window size. TCP stacks limit the range of sequence numbers allowable within a session to maintain the “connected” state within TCP protocol logic. The initial window size specifies a range of acceptable sequence numbers that will qualify as a response to an ACK packet within a session. Various operating systems use different Initial window sizes. The initial window size can be sampled by establishing an ordinary TCP connection.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="even">
<td align="left">126</td>
<td align="left">CAPEC-327</td>
<td align="left">327</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe analyzes the type and order of any TCP header options present within a response segment. Most operating systems use unique ordering and different option sets when options are present. RFC 793 does not specify a required order when options are present, so different implementations use unique ways of ordering or structuring TCP options. TCP options can be generated by ordinary TCP traffic.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="odd">
<td align="left">127</td>
<td align="left">CAPEC-328</td>
<td align="left">328</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">This OS fingerprinting probe performs a checksum on any ASCII data contained within the data portion or a RST packet. Some operating systems will report a human-readable text message in the payload of a ‘RST’ (reset) packet when specific types of connection errors occur. RFC 1122 allows text payloads within reset packets but not all operating systems or routers implement this functionality.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="even">
<td align="left">128</td>
<td align="left">CAPEC-329</td>
<td align="left">329</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses a technique to generate an ICMP Error message (Port Unreachable, Destination Unreachable, Redirect, Source Quench, Time Exceeded, Parameter Problem) from a target and then analyze the amount of data returned or “Quoted” from the originating request that generated the ICMP error message. For this purpose “Port Unreachable” error messages are often used, as generating them requires the attacker to send a UDP datagram to a closed port on the target. The goal of this analysis to make inferences about the type of operating system or firmware that sent the error message in reply. This is useful for identifying unique characteristics of operating systems because the RFC-1122 expected behavior reads: “Every ICMP error message includes the Internet header and at least the first 8 data octets of the datagram that triggered the error; more than 8 octets MAY be sent […].” This contrasts with RFC-792 expected behavior, which limited the quoted text to 64 bits (8 octets). Given the latitude in the specification the resulting RFC-1122 stack implementations often respond with a high degree of variability in the amount of data quoted in the error message because “older” or “legacy” stacks may comply with the RFC-792 specification, while other stacks may choose a longer format in accordance with RFC-1122. As a general rule most operating systems or firmware will quote the first 8 bytes of the datagram triggering the error, but some IP stacks will quote more than the first 8 bytes of data.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="odd">
<td align="left">129</td>
<td align="left">CAPEC-330</td>
<td align="left">330</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary uses a technique to generate an ICMP Error message (Port Unreachable, Destination Unreachable, Redirect, Source Quench, Time Exceeded, Parameter Problem) from a target and then analyze the integrity of data returned or “Quoted” from the originating request that generated the error message. For this purpose “Port Unreachable” error messages are often used, as generating them requires the attacker to send a UDP datagram to a closed port on the target. When replying with an ICMP error message some IP/ICMP stack implementations change aspects of the IP header, change or reverse certain byte orders, reset certain field values to default values which differ between operating system and firmware implementations, and make other changes. Some IP/ICMP stacks are decidedly broken, indicating an idiosyncratic behavior that differs from the RFC specifications, such as the case when miscalculations affect a field value. A tremendous amount of information about the host operating system can be deduced from its ‘echoing’ characteristics. Notably, inspection of key protocol header fields, including the echoed header fields of the encapsulating protocol can yield a wealth of data about the host operating system or firmware version.</td>
<td align="left">Medium</td>
<td align="left">Low</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">9</td>
<td align="left">Medium</td>
<td align="left">CAPEC-312</td>
</tr>
<tr class="even">
<td align="left">130</td>
<td align="left">CAPEC-472</td>
<td align="left">472</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An attacker carefully crafts small snippets of Java Script to efficiently detect the type of browser the potential victim is using. Many web-based attacks need prior knowledge of the web browser including the version of browser to ensure successful exploitation of a vulnerability. Having this knowledge allows an attacker to target the victim with attacks that specifically exploit known or zero day weaknesses in the type and version of the browser used by the victim. Automating this process via Java Script as a part of the same delivery system used to exploit the browser is considered more efficient as the attacker can supply a browser fingerprinting method and integrate it with exploit code, all contained in Java Script and in response to the same web page request by the browser.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-541</td>
</tr>
<tr class="odd">
<td align="left">131</td>
<td align="left">CAPEC-573</td>
<td align="left">573</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary exploits functionality meant to identify information about the currently running processes on the target system to an authorized user. By knowing what processes are running on the target system, the adversary can learn about the target environment as a means towards further malicious behavior.</td>
<td align="left">Low</td>
<td align="left">Low</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">T1057</td>
</tr>
<tr class="even">
<td align="left">132</td>
<td align="left">CAPEC-574</td>
<td align="left">574</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary exploits functionality meant to identify information about the services on the target system to an authorized user. By knowing what services are registered on the target system, the adversary can learn about the target environment as a means towards further malicious behavior. Depending on the operating system, commands that can obtain services information include “sc” and “tasklist/svc” using Tasklist, and “net start” using Net.</td>
<td align="left">Low</td>
<td align="left">Low</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">T1007</td>
</tr>
<tr class="odd">
<td align="left">133</td>
<td align="left">CAPEC-575</td>
<td align="left">575</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary exploits functionality meant to identify information about the domain accounts and their permissions on the target system to an authorized user. By knowing what accounts are registered on the target system, the adversary can inform further and more targeted malicious behavior. Example Windows commands which can acquire this information are: “net user” and “dsquery”.</td>
<td align="left">Low</td>
<td align="left">Low</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">T1087</td>
</tr>
<tr class="even">
<td align="left">134</td>
<td align="left">CAPEC-576</td>
<td align="left">576</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary exploits functionality meant to identify information about user groups and their permissions on the target system to an authorized user. By knowing what users/permissions are registered on the target system, the adversary can inform further and more targeted malicious behavior. An example Windows command which can list local groups is “net localgroup”.</td>
<td align="left">Low</td>
<td align="left">Low</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">T1069</td>
</tr>
<tr class="odd">
<td align="left">135</td>
<td align="left">CAPEC-577</td>
<td align="left">577</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary exploits functionality meant to identify information about the primary users on the target system to an authorized user. They may do this, for example, by reviewing logins or file modification times. By knowing what owners use the target system, the adversary can inform further and more targeted malicious behavior. An example Windows command that may accomplish this is “dir /A ntuser.dat”. Which will display the last modified time of a user’s ntuser.dat file when run within the root folder of a user. This time is synonymous with the last time that user was logged in.</td>
<td align="left">Low</td>
<td align="left">Low</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">T1033</td>
</tr>
<tr class="even">
<td align="left">138</td>
<td align="left">CAPEC-616</td>
<td align="left">616</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary provides a malicious version of a resource at a location that is similar to the expected location of a legitimate resource. After establishing the rogue location, the adversary waits for a victim to visit the location and access the malicious resource.</td>
<td align="left">Medium</td>
<td align="left">Medium</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">T1204.002</td>
</tr>
<tr class="odd">
<td align="left">139</td>
<td align="left">CAPEC-643</td>
<td align="left">643</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary discovers connections between systems by exploiting the target system’s standard practice of revealing them in searchable, common areas. Through the identification of shared folders/drives between systems, the adversary may further their goals of locating and collecting sensitive information/files, or map potential routes for lateral movement within the network.</td>
<td align="left">Medium</td>
<td align="left">Medium</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">T1135</td>
</tr>
<tr class="even">
<td align="left">140</td>
<td align="left">CAPEC-646</td>
<td align="left">646</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">Adversaries may attempt to obtain information about attached peripheral devices and components connected to a computer system. Examples may include discovering the presence of iOS devices by searching for backups, analyzing the Windows registry to determine what USB devices have been connected, or infecting a victim system with malware to report when a USB device has been connected. This may allow the adversary to gain additional insight about the system or network environment, which may be useful in constructing further attacks.</td>
<td align="left">Low</td>
<td align="left">Medium</td>
<td align="right">2</td>
<td align="right">4</td>
<td align="right">8</td>
<td align="left">Medium</td>
<td align="left">T1120</td>
</tr>
<tr class="odd">
<td align="left">141</td>
<td align="left">CAPEC-651</td>
<td align="left">651</td>
<td align="right">4</td>
<td align="left">12, 23, 48, 72</td>
<td align="left">An adversary intercepts a form of communication (e.g. text, audio, video) by way of software (e.g., microphone and audio recording application), hardware (e.g., recording equipment), or physical means (e.g., physical proximity). The goal of eavesdropping is typically to gain unauthorized access to sensitive information about the target for financial, personal, political, or other gains. Eavesdropping is different from a sniffing attack as it does not take place on a network-based communication channel (e.g., IP traffic). Instead, it entails listening in on the raw audio source of a conversation between two or more parties.</td>
<td align="left">Unknown</td>
<td align="left">Medium</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="left">Low</td>
<td align="left">CAPEC-117</td>
</tr>
<tr class="even">
<td align="left">143</td>
<td align="left">CAPEC-112</td>
<td align="left">112</td>
<td align="right">3</td>
<td align="left">13, 14, 16</td>
<td align="left">In this attack, some asset (information, functionality, identity, etc.) is protected by a finite secret value. The attacker attempts to gain access to this asset by using trial-and-error to exhaustively explore all the possible secret values in the hope of finding the secret (or a value that is functionally equivalent) that will unlock the asset. Examples of secrets can include, but are not limited to, passwords, encryption keys, database lookup keys, and initial values to one-way functions. The key factor in this attack is the attackers’ ability to explore the possible secret space rapidly. This, in turn, is a function of the size of the secret space and the computational power the attacker is able to bring to bear on the problem. If the attacker has modest resources and the secret space is large, the challenge facing the attacker is intractable. Assuming a finite secret space, a brute force attack will eventually succeed. The defender must rely on making sure that the time and resources necessary to do so will exceed the value of the information.</td>
<td align="left">Unknown</td>
<td align="left">High</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">5</td>
<td align="left">Low</td>
<td align="left">CWE-330, CWE-326, CWE-521</td>
</tr>
<tr class="odd">
<td align="left">219</td>
<td align="left">CAPEC-114</td>
<td align="left">114</td>
<td align="right">3</td>
<td align="left">22, 25, 34</td>
<td align="left">An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme’s implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target’s authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the “Exploitation of Session Variables, Resource IDs and other Trusted Credentials” attack patterns.</td>
<td align="left">Unknown</td>
<td align="left">Medium</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="left">Low</td>
<td align="left">CWE-287 , CWE-1244</td>
</tr>
<tr class="even">
<td align="left">220</td>
<td align="left">CAPEC-115</td>
<td align="left">115</td>
<td align="right">3</td>
<td align="left">22, 25, 34</td>
<td align="left">An attacker gains access to application, service, or device with the privileges of an authorized or privileged user by evading or circumventing an authentication mechanism. The attacker is therefore able to access protected data without authentication ever having taken place. This refers to an attacker gaining access equivalent to an authenticated user without ever going through an authentication procedure. This is usually the result of the attacker using an unexpected access procedure that does not go through the proper checkpoints where authentication should occur. For example, a web site might assume that all users will click through a given link in order to get to secure material and simply authenticate everyone that clicks the link. However, an attacker might be able to reach secured web content by explicitly entering the path to the content rather than clicking through the authentication link, thereby avoiding the check entirely. This attack pattern differs from other authentication attacks in that attacks of this pattern avoid authentication entirely, rather than faking authentication by exploiting flaws or by stealing credentials from legitimate users.</td>
<td align="left">Unknown</td>
<td align="left">Medium</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="left">Low</td>
<td align="left">CWE-287</td>
</tr>
<tr class="odd">
<td align="left">221</td>
<td align="left">CAPEC-151</td>
<td align="left">151</td>
<td align="right">3</td>
<td align="left">22, 25, 34</td>
<td align="left">Identity Spoofing refers to the action of assuming (i.e., taking on) the identity of some other entity (human or non-human) and then using that identity to accomplish a goal. An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials. Alternatively, an adversary may intercept a message from a legitimate sender and attempt to make it look like the message comes from them without changing its content. The latter form of this attack can be used to hijack credentials from legitimate users. Identity Spoofing attacks need not be limited to transmitted messages - any resource that is associated with an identity (for example, a file with a signature) can be the target of an attack where the adversary attempts to change the apparent identity. This attack differs from Content Spoofing attacks where the adversary does not wish to change the apparent identity of the message but instead wishes to change what the message says. In an Identity Spoofing attack, the adversary is attempting to change the identity of the content.</td>
<td align="left">Medium</td>
<td align="left">Medium</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">CWE-287</td>
</tr>
<tr class="even">
<td align="left">222</td>
<td align="left">CAPEC-194</td>
<td align="left">194</td>
<td align="right">3</td>
<td align="left">22, 25, 34</td>
<td align="left">An adversary takes advantage of improper authentication to provide data or services under a falsified identity. The purpose of using the falsified identity may be to prevent traceability of the provided data or to assume the rights granted to another individual. One of the simplest forms of this attack would be the creation of an email message with a modified “From” field in order to appear that the message was sent from someone other than the actual sender. The root of the attack (in this case the email system) fails to properly authenticate the source and this results in the reader incorrectly performing the instructed action. Results of the attack vary depending on the details of the attack, but common results include privilege escalation, obfuscation of other attacks, and data corruption/manipulation.</td>
<td align="left">Unknown</td>
<td align="left">Medium</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="left">Low</td>
<td align="left">CAPEC-151</td>
</tr>
<tr class="odd">
<td align="left">225</td>
<td align="left">CAPEC-593</td>
<td align="left">593</td>
<td align="right">3</td>
<td align="left">22, 25, 34</td>
<td align="left">This type of attack involves an adversary that exploits weaknesses in an application’s use of sessions in performing authentication. The adversary is able to steal or manipulate an active session and use it to gain unathorized access to the application.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">T1550.001</td>
</tr>
<tr class="even">
<td align="left">226</td>
<td align="left">CAPEC-633</td>
<td align="left">633</td>
<td align="right">3</td>
<td align="left">22, 25, 34</td>
<td align="left">An adversary exploits a weakness in authentication to create an access token (or equivalent) that impersonates a different entity, and then associates a process/thread to that that impersonated token. This action causes a downstream user to make a decision or take action that is based on the assumed identity, and not the response that blocks the adversary.</td>
<td align="left">Unknown</td>
<td align="left">Medium</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="left">Low</td>
<td align="left">T1134.001, T1134.003</td>
</tr>
<tr class="odd">
<td align="left">786</td>
<td align="left">CAPEC-40</td>
<td align="left">40</td>
<td align="right">3</td>
<td align="left">19, 21, 65</td>
<td align="left">This attack exploits terminal devices that allow themselves to be written to by other users. The attacker sends command strings to the target terminal device hoping that the target user will hit enter and thereby execute the malicious command with their privileges. The attacker can send the results (such as copying /etc/passwd) to a known directory and collect once the attack has succeeded.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-248</td>
</tr>
<tr class="even">
<td align="left">144</td>
<td align="left">CAPEC-485</td>
<td align="left">485</td>
<td align="right">2</td>
<td align="left">13, 16</td>
<td align="left">An attacker obtains an authoritative or reputable signer’s private signature key by exploiting a cryptographic weakness in the signature algorithm or pseudorandom number generation and then uses this key to forge signatures from the original signer to mislead a victim into performing actions that benefit the attacker.</td>
<td align="left">Low</td>
<td align="left">High</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">10</td>
<td align="left">Medium</td>
<td align="left">CAPEC-473</td>
</tr>
<tr class="odd">
<td align="left">216</td>
<td align="left">CAPEC-540</td>
<td align="left">540</td>
<td align="right">2</td>
<td align="left">19, 21</td>
<td align="left">An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.</td>
<td align="left">Low</td>
<td align="left">High</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">10</td>
<td align="left">Medium</td>
<td align="left">CAPEC-123</td>
</tr>
<tr class="even">
<td align="left">410</td>
<td align="left">CAPEC-70</td>
<td align="left">70</td>
<td align="right">2</td>
<td align="left">2, 37</td>
<td align="left">An adversary may try certain common or default usernames and passwords to gain access into the system and perform unauthorized actions. An adversary may try an intelligent brute force using empty passwords, known vendor default credentials, as well as a dictionary of common usernames and passwords. Many vendor products come preconfigured with default (and thus well-known) usernames and passwords that should be deleted prior to usage in a production environment. It is a common mistake to forget to remove these default login credentials. Another problem is that users would pick very simple (common) passwords (e.g. “secret” or “password”) that make it easier for the attacker to gain access to the system compared to using a brute force attack or even a dictionary attack using a full dictionary.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">T1078.001, T1110.003</td>
</tr>
<tr class="odd">
<td align="left">525</td>
<td align="left">CAPEC-122</td>
<td align="left">122</td>
<td align="right">2</td>
<td align="left">44, 69</td>
<td align="left">An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">CWE-269 , CWE-732 , CWE-1317</td>
</tr>
<tr class="even">
<td align="left">787</td>
<td align="left">CAPEC-62</td>
<td align="left">62</td>
<td align="right">2</td>
<td align="left">65, 69</td>
<td align="left">An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users’ privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user’s system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply “riding” the existing session cookie.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-21</td>
</tr>
<tr class="odd">
<td align="left">15</td>
<td align="left">CAPEC-470</td>
<td align="left">470</td>
<td align="right">1</td>
<td align="left">2</td>
<td align="left">An attacker is able to leverage access gained to the database to read / write data to the file system, compromise the operating system, create a tunnel for accessing the host machine, and use this access to potentially attack other machines on the same network as the database machine. Traditionally SQL injections attacks are viewed as a way to gain unauthorized read access to the data stored in the database, modify the data in the database, delete the data, etc. However, almost every data base management system (DBMS) system includes facilities that if compromised allow an attacker complete access to the file system, operating system, and full access to the host running the database. The attacker can then use this privileged access to launch subsequent attacks. These facilities include dropping into a command shell, creating user defined functions that can call system level libraries present on the host machine, stored procedures, etc.</td>
<td align="left">Unknown</td>
<td align="left">Very High</td>
<td align="right">1</td>
<td align="right">6</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">CAPEC-66</td>
</tr>
<tr class="even">
<td align="left">147</td>
<td align="left">CAPEC-192</td>
<td align="left">192</td>
<td align="right">1</td>
<td align="left">14</td>
<td align="left">An adversary engages in activities to decipher and/or decode protocol information for a network or application communication protocol used for transmitting information between interconnected nodes or systems on a packet-switched data network. While this type of analysis involves the analysis of a networking protocol inherently, it does not require the presence of an actual or physical network. Although certain techniques for protocol analysis benefit from manipulating live ‘on-the-wire’ interactions between communicating components, static or dynamic analysis techniques applied to executables as well as to device drivers, such as network interface drivers, can also be used to reveal the function and characteristics of a communication protocol implementation. Depending upon the methods used the process may involve observing, interacting, and modifying actual communications occurring between hosts. The goal of protocol analysis is to derive the data transmission syntax, as well as to extract the meaningful content, including packet or content delimiters used by the protocol. This type of analysis is often performed on closed-specification protocols, or proprietary protocols, but is also useful for analyzing publicly available specifications to determine how particular implementations deviate from published specifications.</td>
<td align="left">Low</td>
<td align="left">Low</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">CWE-326</td>
</tr>
<tr class="odd">
<td align="left">387</td>
<td align="left">CAPEC-102</td>
<td align="left">102</td>
<td align="right">1</td>
<td align="left">33</td>
<td align="left">Session sidejacking takes advantage of an unencrypted communication channel between a victim and target system. The attacker sniffs traffic on a network looking for session tokens in unencrypted traffic. Once a session token is captured, the attacker performs malicious actions by using the stolen token with the targeted application to impersonate the victim. This attack is a specific method of session hijacking, which is exploiting a valid session token to gain unauthorized access to a target system or information. Other methods to perform a session hijacking are session fixation, cross-site scripting, or compromising a user or server machine and stealing the session token.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-593</td>
</tr>
<tr class="even">
<td align="left">389</td>
<td align="left">CAPEC-555</td>
<td align="left">555</td>
<td align="right">1</td>
<td align="left">33</td>
<td align="left">This pattern of attack involves an adversary that uses stolen credentials to leverage remote services such as RDP, telnet, SSH, and VNC to log into a system. Once access is gained, any number of malicious activities could be performed.</td>
<td align="left">Unknown</td>
<td align="left">Very High</td>
<td align="right">1</td>
<td align="right">6</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">T1114.002, T1021 , T1133</td>
</tr>
<tr class="odd">
<td align="left">390</td>
<td align="left">CAPEC-644</td>
<td align="left">644</td>
<td align="right">1</td>
<td align="left">33</td>
<td align="left">An adversary obtains (i.e. steals or purchases) legitimate Windows domain credential (e.g. userID and password) hash values to access systems within the domain that leverage the Lan Man (LM) and/or NT Lan Man (NTLM) authentication protocols. When authenticating via LM or NTLM, an authenticating account’s plaintext credentials are not required by the protocols for successful authentication. Instead, the hashed credentials are used to determine if an authentication attempt is valid. If an adversary can obtain an account’s hashed credentials, the hash values can then be passed to a system or service to authenticate, without needing to brute-force the hashes to obtain their cleartext values. Successful Pass The Hash attacks result in the adversary fully authenticating as the targeted account, which can further allow the adversary to laterally move within the network, impersonate a legitimate user, and/or download/install malware to systems within the domain. This technique can be performed against any operating system that leverages the LM or NTLM protocols even if the operating system is not Windows-based, since these systems/accounts may still authenticate to a Windows domain.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">T1550.002</td>
</tr>
<tr class="even">
<td align="left">391</td>
<td align="left">CAPEC-645</td>
<td align="left">645</td>
<td align="right">1</td>
<td align="left">33</td>
<td align="left">An adversary uses stolen Kerberos tickets to access systems/resources that leverage the Kerberos authentication protocol. The Kerberos authentication protocol centers around a ticketing system which is used to request/grant access to services and to then access the requested services. An adversary can obtain any one of these tickets (e.g. Service Ticket, Ticket Granting Ticket, Silver Ticket, or Golden Ticket) to authenticate to a system/resource without needing the account’s credentials. Depending on the ticket obtained, the adversary may be able to access a particular resource or generate TGTs for any account within an Active Directory Domain.</td>
<td align="left">Low</td>
<td align="left">High</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">10</td>
<td align="left">Medium</td>
<td align="left">T1550.003</td>
</tr>
<tr class="odd">
<td align="left">401</td>
<td align="left">CAPEC-37</td>
<td align="left">37</td>
<td align="right">1</td>
<td align="left">35</td>
<td align="left">An attacker examines a target system to find sensitive data that has been embedded within it. This information can reveal confidential contents, such as account numbers or individual keys/credentials that can be used as an intermediate step in a larger attack.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">T1552.004</td>
</tr>
<tr class="even">
<td align="left">403</td>
<td align="left">CAPEC-459</td>
<td align="left">459</td>
<td align="right">1</td>
<td align="left">36</td>
<td align="left">An adversary exploits a weakness resulting from using a hashing algorithm with weak collision resistance to generate certificate signing requests (CSR) that contain collision blocks in their “to be signed” parts. The adversary submits one CSR to be signed by a trusted certificate authority then uses the signed blob to make a second certificate appear signed by said certificate authority. Due to the hash collision, both certificates, though different, hash to the same value and so the signed blob works just as well in the second certificate. The net effect is that the adversary’s second X.509 certificate, which the Certification Authority has never seen, is now signed and validated by that Certification Authority. Alternatively, the second certificate could be a signing certificate. Thus the adversary is able to start their own Certification Authority that is anchored in its root of trust in the legitimate Certification Authority that has signed the attacker’s first X.509 certificate. If the original Certificate Authority was accepted by default by browsers, so will the Certificate Authority set up by the adversary and any certificates that it signs. As a result, the adversary is able to generate any SSL certificates to impersonate any web server, and the user’s browser will not issue any warning to the victim. This can be used to compromise HTTPS communications and other types of systems where PKI and X.509 certificates may be used (e.g., VPN, IPSec).</td>
<td align="left">Medium</td>
<td align="left">Very High</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="right">18</td>
<td align="left">Critical</td>
<td align="left">T1553.004</td>
</tr>
<tr class="odd">
<td align="left">405</td>
<td align="left">CAPEC-608</td>
<td align="left">608</td>
<td align="right">1</td>
<td align="left">36</td>
<td align="left">The use of cryptanalytic techniques to derive cryptographic keys or otherwise effectively defeat cellular encryption to reveal traffic content. Some cellular encryption algorithms such as A5/1 and A5/2 (specified for GSM use) are known to be vulnerable to such attacks and commercial tools are available to execute these attacks and decrypt mobile phone conversations in real-time. Newer encryption algorithms in use by UMTS and LTE are stronger and currently believed to be less vulnerable to these types of attacks. Note, however, that an attacker with a Cellular Rogue Base Station can force the use of weak cellular encryption even by newer mobile devices.</td>
<td align="left">Unknown</td>
<td align="left">High</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">5</td>
<td align="left">Low</td>
<td align="left">CAPEC-97</td>
</tr>
<tr class="even">
<td align="left">406</td>
<td align="left">CAPEC-614</td>
<td align="left">614</td>
<td align="right">1</td>
<td align="left">36</td>
<td align="left">SIM cards are the de facto trust anchor of mobile devices worldwide. The cards protect the mobile identity of subscribers, associate devices with phone numbers, and increasingly store payment credentials, for example in NFC-enabled phones with mobile wallets. This attack leverages over-the-air (OTA) updates deployed via cryptographically-secured SMS messages to deliver executable code to the SIM. By cracking the DES key, an attacker can send properly signed binary SMS messages to a device, which are treated as Java applets and are executed on the SIM. These applets are allowed to send SMS, change voicemail numbers, and query the phone location, among many other predefined functions. These capabilities alone provide plenty of potential for abuse.</td>
<td align="left">Unknown</td>
<td align="left">High</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">5</td>
<td align="left">Low</td>
<td align="left">CAPEC-186</td>
</tr>
<tr class="odd">
<td align="left">408</td>
<td align="left">CAPEC-190</td>
<td align="left">190</td>
<td align="right">1</td>
<td align="left">37</td>
<td align="left">An attacker analyzes a binary file or executable for the purpose of discovering the structure, function, and possibly source-code of the file by using a variety of analysis techniques to effectively determine how the software functions and operates. This type of analysis is also referred to as Reverse Code Engineering, as techniques exist for extracting source code from an executable. Several techniques are often employed for this purpose, both black box and white box. The use of computer bus analyzers and packet sniffers allows the binary to be studied at a level of interactions with its computing environment, such as a host OS, inter-process communication, and/or network communication. This type of analysis falls into the ‘black box’ category because it involves behavioral analysis of the software without reference to source code, object code, or protocol specifications.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">CAPEC-167</td>
</tr>
<tr class="even">
<td align="left">409</td>
<td align="left">CAPEC-191</td>
<td align="left">191</td>
<td align="right">1</td>
<td align="left">37</td>
<td align="left">An adversary engages in activities to discover any sensitive constants present within the compiled code of an executable.These constants may include literal ASCII strings within the file itself, or possibly strings hard-coded into particular routines that can be revealed by code refactoring methods including static and dynamic analysis. One specific example of a sensitive string is a hard-coded password. Typical examples of software with hard-coded passwords include server-side executables which may check for a hard-coded password or key during a user’s authentication with the server. Hard-coded passwords can also be present in client-side executables which utilize the password or key when connecting to either a remote component, such as a database server, licensing server, or otherwise, or a processes on the same host that expects a key or password. When analyzing an executable the adversary may search for the presence of such strings by analyzing the byte-code of the file itself. Example utilities for revealing strings within a file include ‘strings,’ ‘grep,’ or other variants of these programs depending upon the type of operating system used. These programs can be used to dump any ASCII or UNICODE strings contained within a program. Strings can also be searched for using a hex editors by loading the binary or object code file and utilizing native search functions such as regular expressions.Additionally, sensitive numeric values can occur within an executable. This can be used to discover the location of cryptographic constants.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">T1552.001</td>
</tr>
<tr class="odd">
<td align="left">518</td>
<td align="left">CAPEC-126</td>
<td align="left">126</td>
<td align="right">1</td>
<td align="left">43</td>
<td align="left">An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.</td>
<td align="left">High</td>
<td align="left">Very High</td>
<td align="right">4</td>
<td align="right">6</td>
<td align="right">24</td>
<td align="left">Critical</td>
<td align="left">CAPEC-153</td>
</tr>
<tr class="even">
<td align="left">700</td>
<td align="left">CAPEC-121</td>
<td align="left">121</td>
<td align="right">1</td>
<td align="left">54</td>
<td align="left">An adversary exploits a sample, demonstration, test, or debug interface that is unintentionally enabled on a production system, with the goal of gleaning information or leveraging functionality that would otherwise be unavailable. Non-production interfaces are insecure by default and should not be resident on production systems, since they may reveal sensitive information or functionality that should not be known to end-users. However, such interfaces may be unintentionally left enabled on a production system due to configuration errors, supply chain mismanagement, or other pre-deployment activities.Ultimately, failure to properly disable non-production interfaces, in a production environment, may expose a great deal of diagnostic information or functionality to an adversary, which can be utilized to further refine their attack. Moreover, many non-production interfaces do not have adequate security controls or may not have undergone rigorous testing since they were not intended for use in production environments. As such, they may contain many flaws and vulnerabilities that could allow an adversary to severely disrupt a target.</td>
<td align="left">Low</td>
<td align="left">High</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">10</td>
<td align="left">Medium</td>
<td align="left">CAPEC-113</td>
</tr>
<tr class="odd">
<td align="left">701</td>
<td align="left">CAPEC-125</td>
<td align="left">125</td>
<td align="right">1</td>
<td align="left">54</td>
<td align="left">An adversary consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow. When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target’s operations. The key factor in a flooding attack is the number of requests the adversary can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">T1498.001</td>
</tr>
<tr class="even">
<td align="left">702</td>
<td align="left">CAPEC-130</td>
<td align="left">130</td>
<td align="right">1</td>
<td align="left">54</td>
<td align="left">An adversary causes the target to allocate excessive resources to servicing the attackers’ request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.</td>
<td align="left">Medium</td>
<td align="left">Medium</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">12</td>
<td align="left">Medium</td>
<td align="left">T1499.003</td>
</tr>
<tr class="odd">
<td align="left">705</td>
<td align="left">CAPEC-229</td>
<td align="left">229</td>
<td align="right">1</td>
<td align="left">54</td>
<td align="left">This attack exploits certain serialized data parsers (e.g., XML, YAML, etc.) which manage data in an inefficient manner. The attacker crafts an serialized data file with multiple configuration parameters in the same dataset. In a vulnerable parser, this results in a denial of service condition where CPU resources are exhausted because of the parsing algorithm. The weakness being exploited is tied to parser implementation and not language specific.</td>
<td align="left">High</td>
<td align="left">High</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">20</td>
<td align="left">Critical</td>
<td align="left">CAPEC-231</td>
</tr>
<tr class="even">
<td align="left">708</td>
<td align="left">CAPEC-469</td>
<td align="left">469</td>
<td align="right">1</td>
<td align="left">54</td>
<td align="left">An attacker performs flooding at the HTTP level to bring down only a particular web application rather than anything listening on a TCP/IP connection. This denial of service attack requires substantially fewer packets to be sent which makes DoS harder to detect. This is an equivalent of SYN flood in HTTP. The idea is to keep the HTTP session alive indefinitely and then repeat that hundreds of times. This attack targets resource depletion weaknesses in web server software. The web server will wait to attacker’s responses on the initiated HTTP sessions while the connection threads are being exhausted.</td>
<td align="left">Unknown</td>
<td align="left">Low</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="left">Low</td>
<td align="left">T1499.001, T1499.004</td>
</tr>
<tr class="odd">
<td align="left">711</td>
<td align="left">CAPEC-221</td>
<td align="left">221</td>
<td align="right">1</td>
<td align="left">55</td>
<td align="left">This attack takes advantage of the entity replacement property of certain data serialization languages (e.g., XML, YAML, etc.) where the value of the replacement is a URI. A well-crafted file could have the entity refer to a URI that consumes a large amount of resources to create a denial of service condition. This can cause the system to either freeze, crash, or execute arbitrary code depending on the URI.</td>
<td align="left">Unknown</td>
<td align="left">Unknown</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">Low</td>
<td align="left">CAPEC-122, CAPEC-278</td>
</tr>
<tr class="even">
<td align="left">724</td>
<td align="left">CAPEC-441</td>
<td align="left">441</td>
<td align="right">1</td>
<td align="left">57</td>
<td align="left">An adversary installs or adds malicious logic (also known as malware) into a seemingly benign component of a fielded system. This logic is often hidden from the user of the system and works behind the scenes to achieve negative impacts. With the proliferation of mass digital storage and inexpensive multimedia devices, Bluetooth and 802.11 support, new attack vectors for spreading malware are emerging for things we once thought of as innocuous greeting cards, picture frames, or digital projectors. This pattern of attack focuses on systems already fielded and used in operation as opposed to systems and their components that are still under development and part of the supply chain.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CWE-284</td>
</tr>
<tr class="odd">
<td align="left">725</td>
<td align="left">CAPEC-474</td>
<td align="left">474</td>
<td align="right">1</td>
<td align="left">57</td>
<td align="left">An attacker obtains an authoritative or reputable signer’s private signature key by theft and then uses this key to forge signatures from the original signer to mislead a victim into performing actions that benefit the attacker.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CAPEC-473</td>
</tr>
<tr class="even">
<td align="left">726</td>
<td align="left">CAPEC-479</td>
<td align="left">479</td>
<td align="right">1</td>
<td align="left">57</td>
<td align="left">An adversary exploits a weakness in authorization and installs a new root certificate on a compromised system. Certificates are commonly used for establishing secure TLS/SSL communications within a web browser. When a user attempts to browse a website that presents a certificate that is not trusted an error message will be displayed to warn the user of the security risk. Depending on the security settings, the browser may not allow the user to establish a connection to the website. Adversaries have used this technique to avoid security warnings prompting users when compromised systems connect over HTTPS to adversary controlled web servers that spoof legitimate websites in order to collect login credentials.</td>
<td align="left">Low</td>
<td align="left">Low</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">T1553.004</td>
</tr>
<tr class="odd">
<td align="left">727</td>
<td align="left">CAPEC-536</td>
<td align="left">536</td>
<td align="right">1</td>
<td align="left">57</td>
<td align="left">An attacker with access to data files and processes on a victim’s system injects malicious data into critical operational data during configuration or recalibration, causing the victim’s system to perform in a suboptimal manner that benefits the adversary.</td>
<td align="left">Low</td>
<td align="left">High</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">10</td>
<td align="left">Medium</td>
<td align="left">CAPEC-176</td>
</tr>
<tr class="even">
<td align="left">728</td>
<td align="left">CAPEC-546</td>
<td align="left">546</td>
<td align="right">1</td>
<td align="left">57</td>
<td align="left">An adversary obtains unauthorized information due to insecure or incomplete data deletion in a multi-tenant environment. If a cloud provider fails to completely delete storage and data from former cloud tenants’ systems/resources, once these resources are allocated to new, potentially malicious tenants, the latter can probe the provided resources for sensitive information still there.</td>
<td align="left">Low</td>
<td align="left">Medium</td>
<td align="right">2</td>
<td align="right">4</td>
<td align="right">8</td>
<td align="left">Medium</td>
<td align="left">CAPEC-545</td>
</tr>
<tr class="odd">
<td align="left">815</td>
<td align="left">CAPEC-127</td>
<td align="left">127</td>
<td align="right">1</td>
<td align="left">69</td>
<td align="left">An adversary crafts a request to a target that results in the target listing/indexing the content of a directory as output. One common method of triggering directory contents as output is to construct a request containing a path that terminates in a directory name rather than a file name since many applications are configured to provide a list of the directory’s contents when such a request is received. An adversary can use this to explore the directory tree on a target as well as learn the names of files. This can often end up revealing test files, backup files, temporary files, hidden files, configuration files, user accounts, script contents, as well as naming conventions, all of which can be used by an attacker to mount additional attacks.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">T1083</td>
</tr>
<tr class="even">
<td align="left">817</td>
<td align="left">CAPEC-180</td>
<td align="left">180</td>
<td align="right">1</td>
<td align="left">69</td>
<td align="left">An attacker exploits a weakness in the configuration of access controls and is able to bypass the intended protection that these measures guard against and thereby obtain unauthorized access to the system or network. Sensitive functionality should always be protected with access controls. However configuring all but the most trivial access control systems can be very complicated and there are many opportunities for mistakes. If an attacker can learn of incorrectly configured access security settings, they may be able to exploit this in an attack. Most commonly, attackers would take advantage of controls that provided too little protection for sensitive activities in order to perform actions that should be denied to them. In some circumstances, an attacker may be able to take advantage of overly restrictive access control policies, initiating denial of services (if an application locks because it unexpectedly failed to be granted access) or causing other legitimate actions to fail due to security. The latter class of attacks, however, is usually less severe and easier to detect than attacks based on inadequate security restrictions. This attack pattern differs from CAPEC 1, “Accessing Functionality Not Properly Constrained by ACLs” in that the latter describes attacks where sensitive functionality lacks access controls, where, in this pattern, the access control is present, but incorrectly configured.</td>
<td align="left">High</td>
<td align="left">Medium</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="right">16</td>
<td align="left">High</td>
<td align="left">CAPEC-122</td>
</tr>
<tr class="odd">
<td align="left">818</td>
<td align="left">CAPEC-206</td>
<td align="left">206</td>
<td align="right">1</td>
<td align="left">69</td>
<td align="left">The attacker extracts credentials used for code signing from a production environment and then uses these credentials to sign malicious content with the developer’s key. Many developers use signing keys to sign code or hashes of code. When users or applications verify the signatures are accurate they are led to believe that the code came from the owner of the signing key and that the code has not been modified since the signature was applied. If the attacker has extracted the signing credentials then they can use those credentials to sign their own code bundles. Users or tools that verify the signatures attached to the code will likely assume the code came from the legitimate developer and install or run the code, effectively allowing the attacker to execute arbitrary code on the victim’s computer.</td>
<td align="left">Unknown</td>
<td align="left">Very High</td>
<td align="right">1</td>
<td align="right">6</td>
<td align="right">6</td>
<td align="left">Low</td>
<td align="left">T1553.002</td>
</tr>
<tr class="even">
<td align="left">819</td>
<td align="left">CAPEC-234</td>
<td align="left">234</td>
<td align="right">1</td>
<td align="left">69</td>
<td align="left">An attacker gains control of a process that is assigned elevated privileges in order to execute arbitrary code with those privileges. Some processes are assigned elevated privileges on an operating system, usually through association with a particular user, group, or role. If an attacker can hijack this process, they will be able to assume its level of privilege in order to execute their own code. Processes can be hijacked through improper handling of user input (for example, a buffer overflow or certain types of injection attacks) or by utilizing system utilities that support process control that have been inadequately secured.</td>
<td align="left">Unknown</td>
<td align="left">Medium</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
<td align="left">Low</td>
<td align="left">T1574.005</td>
</tr>
<tr class="odd">
<td align="left">823</td>
<td align="left">CAPEC-642</td>
<td align="left">642</td>
<td align="right">1</td>
<td align="left">69</td>
<td align="left">Adversaries know that certain binaries will be regularly executed as part of normal processing. If these binaries are not protected with the appropriate file system permissions, it could be possible to replace them with malware. This malware might be executed at higher system permission levels. A variation of this pattern is to discover self-extracting installation packages that unpack binaries to directories with weak file permissions which it does not clean up appropriately. These binaries can be replaced by malware, which can then be executed.</td>
<td align="left">Unknown</td>
<td align="left">High</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">5</td>
<td align="left">Low</td>
<td align="left">T1574.005, T1574.010</td>
</tr>
<tr class="even">
<td align="left">947</td>
<td align="left">CAPEC-586</td>
<td align="left">586</td>
<td align="right">1</td>
<td align="left">75</td>
<td align="left">An adversary attempts to exploit an application by injecting additional, malicious content during its processing of serialized objects. Developers leverage serialization in order to convert data or state into a static, binary format for saving to disk or transferring over a network. These objects are then deserialized when needed to recover the data/state. By injecting a malformed object into a vulnerable application, an adversary can potentially compromise the application by manipulating the deserialization process. This can result in a number of unwanted outcomes, including remote code execution.</td>
<td align="left">Medium</td>
<td align="left">High</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">15</td>
<td align="left">High</td>
<td align="left">CWE-502</td>
</tr>
</tbody>
</table>
